generator client {
  provider = "prisma-client-js"
}

generator kysely {
  provider     = "prisma-kysely"
  output       = "../server/src/db"
  fileName     = "types.ts"
  enumFileName = "enums.ts"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Role {
  id          String   @id @default(uuid())
  name        String   @unique
  displayName String
  description String?
  permissions Json
  isBuiltIn   Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  users       User[]
}

model User {
  id                    String                   @id @default(uuid())
  email                 String                   @unique
  password              String
  name                  String
  role                  String                   @default("staff")
  isActive              Boolean                  @default(true)
  createdAt             DateTime                 @default(now())
  updatedAt             DateTime                 @updatedAt
  mustChangePassword    Boolean                  @default(false)
  roleId                String?
  tokenVersion          Int                      @default(0)
  extraAccess           Json                     @default("[]") // Array of AccessFeature strings for exceptions beyond role
  userRole              Role?                    @relation(fields: [roleId], references: [id])
  permissionOverrides   UserPermissionOverride[]
  gridPreferences       UserGridPreference[]
  inventoryTransactions InventoryTransaction[]
  // NOTE: fabricTransactions removed - use fabricColourTransactions
  fabricColourTransactions FabricColourTransaction[] @relation("FabricColourTxnCreator")
  returnStatusHistory   ReturnStatusHistory[]
  processedRepackItems  RepackingQueueItem[]     @relation("RepackingProcessor")
  createdWriteOffs      WriteOffLog[]            @relation("WriteOffCreator")
  rtoInwardedLines      OrderLine[]              @relation("RtoInwardedBy")
  customizedLines       OrderLine[]              @relation("CustomizedBy")
  recordedPayments      OrderPayment[]           // Payments recorded by this user
  // Return tracking relations
  returnRequestedLines  OrderLine[]              @relation("ReturnRequestedBy")
  returnReceivedLines   OrderLine[]              @relation("ReturnReceivedBy")
  returnClosedManuallyLines OrderLine[]          @relation("ReturnClosedManuallyBy")
  // Settings updates
  returnSettingsUpdates ReturnSettings[]
  // Fabric invoices
  fabricInvoices        FabricInvoice[]  @relation("FabricInvoiceCreator")
  // Finance relations
  financeInvoices       Invoice[]        @relation("InvoiceCreator")
  financePayments       Payment[]        @relation("PaymentCreator")
  paymentInvoiceMatches PaymentInvoice[] @relation("PaymentInvoiceMatcher")
  ledgerEntries         LedgerEntry[]    @relation("LedgerEntryCreator")
  payrollRunsCreated    PayrollRun[]     @relation("PayrollRunCreator")
  payrollRunsConfirmed  PayrollRun[]     @relation("PayrollRunConfirmer")

  @@index([roleId])
}

model UserPermissionOverride {
  id         String   @id @default(uuid())
  userId     String
  permission String
  granted    Boolean
  createdAt  DateTime @default(now())
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, permission])
  @@index([userId])
}

model UserGridPreference {
  id             String    @id @default(uuid())
  userId         String
  gridId         String
  visibleColumns String    // JSON array of visible column IDs
  columnOrder    String    // JSON array of column IDs in display order
  columnWidths   String    // JSON object of columnId -> width mappings
  adminVersion   DateTime? // Tracks which admin defaults user has acknowledged
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, gridId])
  @@index([userId])
  @@index([gridId])
}

model Product {
  id                       String      @id @default(uuid())
  name                     String
  styleCode                String?
  category                 String
  productType              String
  gender                   String      @default("unisex")
  // NOTE: fabricTypeId removed - fabric info comes from variation BOM lines
  baseProductionTimeMins   Int         @default(60)
  defaultFabricConsumption Float?
  imageUrl                 String?
  isActive                 Boolean     @default(true)
  isReturnable             Boolean     @default(true)
  nonReturnableReason      String?     // 'sale_item', 'hygiene', 'custom_made', etc.
  createdAt                DateTime    @default(now())
  updatedAt                DateTime    @updatedAt
  shopifyProductId         String?     @unique
  shopifyHandle            String?
  exchangeCount            Int         @default(0)
  returnCount              Int         @default(0)
  writeOffCount            Int         @default(0)
  packagingCost            Float?
  shopifyProductIds        String[]    @default([])
  variations               Variation[]
  bomTemplates             ProductBomTemplate[] // BOM structure for this product

  @@index([category])
  @@index([shopifyHandle])
  @@index([name])
  @@index([styleCode])
}

model Variation {
  id                     String  @id @default(uuid())
  productId              String
  colorName              String
  standardColor          String?
  colorHex               String?
  // NOTE: fabricId/fabricColourId removed - fabric assignment via BOM (VariationBomLine.fabricColourId)
  imageUrl               String?
  isActive               Boolean @default(true)
  hasLining              Boolean @default(false)
  packagingCost          Float?
  laborMinutes           Float?
  bomCost                Float?   // Computed total BOM cost (sum of SKU bomCosts)
  shopifySourceProductId String?
  shopifySourceHandle    String?
  skus                   Sku[]
  product                Product @relation(fields: [productId], references: [id])
  bomLines               VariationBomLine[] // BOM overrides for this variation (fabric assigned here)

  @@unique([productId, colorName])
  @@index([productId])
  @@index([shopifySourceProductId])
}

model Sku {
  id                     String                        @id @default(uuid())
  skuCode                String                        @unique
  variationId            String
  size                   String
  fabricConsumption      Float                         @default(1.5)
  mrp                    Float
  currentBalance         Int                           @default(0) // Materialized balance: updated atomically on every transaction
  targetStockQty         Int                           @default(10)
  targetStockMethod      String                        @default("day14")
  isActive               Boolean                       @default(true)
  shopifyInventoryItemId String?
  shopifyVariantId       String?
  exchangeCount          Int                           @default(0)
  returnCount            Int                           @default(0)
  writeOffCount          Int                           @default(0)
  customizationCount     Int                           @default(0)
  customizationNotes     String?
  customizationType      String?
  customizationValue     String?
  isCustomSku            Boolean                       @default(false)
  linkedOrderLineId      String?                       @unique
  parentSkuId            String?
  packagingCost          Float?
  laborMinutes           Float?
  bomCost                Float?   // Computed total BOM cost (fabric + trims + services)
  feedbackProductLinks   FeedbackProductLink[]
  reconciliationItems    InventoryReconciliationItem[]
  inventoryTransactions  InventoryTransaction[]
  orderLines             OrderLine[]
  productionBatches      ProductionBatch[]
  repackingQueueItems    RepackingQueueItem[]
  replacementItems       ReplacementItem[]
  exchangeRequestLines   ReturnRequestLine[]           @relation("ExchangeSku")
  returnRequestLines     ReturnRequestLine[]           @relation("ReturnedSku")
  shopifyInventoryCache  ShopifyInventoryCache?
  parentSku              Sku?                          @relation("CustomSkus", fields: [parentSkuId], references: [id])
  customSkus             Sku[]                         @relation("CustomSkus")
  variation              Variation                     @relation(fields: [variationId], references: [id])
  writeOffLogs           WriteOffLog[]
  bomLines               SkuBomLine[]                  // NEW: BOM overrides for this SKU
  monthlySnapshots       MonthlyStockSnapshot[]

  @@index([variationId])
  @@index([parentSkuId])
  @@index([isCustomSku])
}

model CostConfig {
  id                     String   @id @default(uuid())
  laborRatePerMin        Float    @default(2.50)
  defaultPackagingCost   Float    @default(50)
  lastUpdated            DateTime @default(now())
  gstRateAbove           Float    @default(18)
  gstRateBelow           Float    @default(5)
  gstThreshold           Float    @default(2500)
  // Monthly overhead costs for P&L analysis
  monthlyLaborOverhead   Float?   // Default: Rs 15,00,000
  monthlyMarketingBudget Float?   // Default: Rs 15,00,000
}

// ============================================
// MATERIAL HIERARCHY (3-tier system)
// ============================================
// NOTE: FabricType model removed - replaced by Material model

// Level 1: Base fiber/material (replaces FabricType conceptually)
model Material {
  id          String   @id @default(uuid())
  name        String   @unique // "Linen", "Pima Cotton", "Cotton", "Utility"
  description String?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  fabrics     Fabric[] @relation("MaterialFabrics")
}

// Level 3: Color variant (the actual inventory item)
model FabricColour {
  id             String   @id @default(uuid())
  fabricId       String
  code           String?  @unique // Short reference code e.g. "LIN-60L-NVY"
  colourName     String   // "Navy Blue", "Rust", "Natural"
  standardColour String?  // Normalized: "blue", "red", "beige"
  colourHex      String?

  // Cost/supply overrides (null = inherit from Fabric)
  costPerUnit    Float?
  partyId        String?
  leadTimeDays   Int?
  minOrderQty    Float?

  currentBalance Float    @default(0) // Materialized balance: updated atomically by DB trigger
  isOutOfStock   Boolean  @default(false) // Manual flag to mark fabric as out of stock

  isActive       Boolean  @default(true)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  fabric         Fabric   @relation("FabricColours", fields: [fabricId], references: [id])
  party          Party?    @relation("FabricColourParty", fields: [partyId], references: [id])

  // BOM usages (fabric assignment via these tables)
  variationBomLines VariationBomLine[]
  skuBomLines       SkuBomLine[]

  // Transactions and reconciliation
  // NOTE: Direct variation link removed - use variationBomLines for fabric->variation
  transactions             FabricColourTransaction[]
  reconciliationItems      FabricColourReconciliationItem[]
  invoiceLines             FabricInvoiceLine[] @relation("InvoiceLineFabricColour")

  @@unique([fabricId, colourName])
  @@index([fabricId])
  @@index([partyId])
  @@index([fabricId, isActive]) // Composite index for active colours per fabric
}

model Fabric {
  id                  String                     @id @default(uuid())
  // NOTE: fabricTypeId removed - fabric now links directly to Material
  name                String
  colorName           String                     @default("N/A")
  standardColor       String?
  colorHex            String?
  costPerUnit         Float?
  partyId             String?
  isActive            Boolean                    @default(true)

  // Material hierarchy fields
  materialId          String?                    // Link to Material model
  constructionType    String?                    // "knit", "woven"
  pattern             String?                    // "single_jersey", "french_terry", "twill", "plain"
  weight              Float?                     // 180 (for gsm), 40 (for lea)
  weightUnit          String?                    // "gsm", "lea", "oz"
  composition         String?                    // "100% Cotton", "55% Linen 45% Cotton"
  avgShrinkagePct     Float?                     // Shrinkage percentage
  defaultLeadTimeDays Int?                       // Default lead time for colours
  defaultMinOrderQty  Float?                     // Default min order for colours
  unit                String?                    // "m", "kg"

  party               Party?                     @relation(fields: [partyId], references: [id])
  material            Material?                  @relation("MaterialFabrics", fields: [materialId], references: [id])
  fabricOrders        FabricOrder[]
  reconciliationItems FabricReconciliationItem[]
  colours             FabricColour[]             @relation("FabricColours")

  @@unique([materialId, name]) // Prevent duplicate fabric names under the same material
  @@index([partyId])
  @@index([materialId])
  @@index([constructionType])
  @@index([pattern])
}

/// Reusable accounting recipe — multiple parties share the same TransactionType
model TransactionType {
  id                   String   @id @default(uuid())
  name                 String   @unique  // "Fabric Purchase", "Service Payment"
  description          String?
  debitAccountCode     String?  // What to debit for outgoing (FABRIC_INVENTORY, etc.)
  creditAccountCode    String?  // What to credit for incoming (SALES_REVENUE, etc.)
  defaultGstRate       Float?   // Default GST % (18, 5, 0)
  defaultTdsApplicable Boolean  @default(false)
  defaultTdsSection    String?  // 194C, 194J, 194I, 194H
  defaultTdsRate       Float?   // Default TDS %
  invoiceRequired      Boolean  @default(true)
  expenseCategory      String?  // P&L category (fabric, service, rent, etc.)
  isActive             Boolean  @default(true)
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  parties Party[]
}

model Party {
  id                String   @id @default(uuid())
  name              String   @unique
  category          String   // fabric, trims, service, rent, marketing, logistics, packaging, statutory, other
  contactName       String?
  email             String?
  phone             String?
  address           String?
  gstin             String?
  pan               String?
  stateCode         String?
  tdsApplicable     Boolean  @default(false)
  tdsSection        String?
  tdsRate           Float?
  bankAccountName   String?
  bankAccountNumber String?
  bankIfsc          String?
  bankName          String?
  razorpayContactId String?
  paymentTermsDays  Int?
  aliases           String[] @default([])
  invoiceRequired   Boolean  @default(true)
  isActive          Boolean  @default(true)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  transactionTypeId  String?
  transactionType    TransactionType? @relation(fields: [transactionTypeId], references: [id])

  fabrics                    Fabric[]
  fabricOrders               FabricOrder[]
  fabricColourTransactions   FabricColourTransaction[] @relation("FabricColourTxnParty")
  fabricColours              FabricColour[]      @relation("FabricColourParty")
  trimItems                  TrimItem[]          @relation("TrimParty")
  serviceItems               ServiceItem[]
  fabricInvoices             FabricInvoice[]     @relation("FabricInvoiceParty")
  financeInvoices            Invoice[]           @relation("InvoiceParty")
  financePayments            Payment[]           @relation("PaymentParty")
  employee                   Employee?
  bankTransactions           BankTransaction[]   @relation("BankTxnParty")

  @@index([category])
  @@index([transactionTypeId])
}

// NOTE: FabricTransaction model removed - use FabricColourTransaction instead

model FabricOrder {
  id           String    @id @default(uuid())
  fabricId     String
  partyId      String
  qtyOrdered   Float
  unit         String
  costPerUnit  Float
  totalCost    Float
  orderDate    DateTime  @default(now())
  expectedDate DateTime?
  receivedDate DateTime?
  qtyReceived  Float?
  status       String    @default("ordered")
  notes        String?
  fabric       Fabric    @relation(fields: [fabricId], references: [id])
  party        Party     @relation(fields: [partyId], references: [id])

  @@index([fabricId])
  @@index([partyId])
  @@index([status])
}

model InventoryTransaction {
  id                String   @id @default(uuid())
  skuId             String
  txnType           String
  qty               Int
  reason            String
  referenceId       String?
  notes             String?
  warehouseLocation String?
  source            String?
  destination       String?
  tailorNumber      String?
  performedBy       String?
  repackingBarcode  String?
  userNotes         String?
  orderNotes        String?
  cohNotes          String?
  orderNumber       String?
  createdById       String
  createdAt         DateTime @default(now())
  createdBy         User     @relation(fields: [createdById], references: [id])
  sku               Sku      @relation(fields: [skuId], references: [id])

  @@index([skuId])
  @@index([txnType])
  @@index([createdAt])
  @@index([skuId, reason, createdAt])
  @@index([skuId, txnType])
  @@index([referenceId])
  @@index([orderNumber])
}

model Customer {
  id                String          @id @default(uuid())
  shopifyCustomerId String?         @unique
  email             String          @unique
  phone             String?
  firstName         String?
  lastName          String?
  defaultAddress    String?
  tags              String?
  acceptsMarketing  Boolean         @default(false)
  firstOrderDate    DateTime?
  lastOrderDate     DateTime?
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt
  exchangeCount     Int             @default(0)
  returnCount       Int             @default(0)
  rtoCount          Int             @default(0)  // Total lines RTO'd
  rtoOrderCount     Int             @default(0)  // Number of orders with at least one RTO
  rtoValue          Decimal         @default(0)  @db.Decimal(12, 2) // Total value of RTO'd items
  orderCount        Int             @default(0)  // Denormalized count of non-cancelled orders (for fast stats lookup)
  tier              String          @default("bronze")
  ltv               Int             @default(0)  // Stored LTV, updated incrementally on order changes
  feedback          Feedback[]
  orders            Order[]
  returnRequests    ReturnRequest[]
  financeInvoices   Invoice[] @relation("InvoiceCustomer")
  financePayments   Payment[] @relation("PaymentCustomer")

  @@index([createdAt])
}

model Order {
  id                   String             @id @default(uuid())
  orderNumber          String             @unique
  shopifyOrderId       String?            @unique
  channel              String             @default("shopify")
  customerId           String?
  customerName         String
  customerEmail        String?
  customerPhone        String?
  shippingAddress      String?
  orderDate            DateTime           @default(now())
  internalNotes        String?
  paymentMethod        String?
  status               String             @default("open")
  isArchived           Boolean            @default(false)
  archivedAt           DateTime?
  releasedToShipped    Boolean            @default(false)
  releasedToCancelled  Boolean            @default(false)
  totalAmount          Float
  createdAt            DateTime           @default(now())
  syncedAt             DateTime?
  codRemittanceUtr     String?
  codRemittedAmount    Float?
  codRemittedAt        DateTime?
  codShopifySyncError  String?
  codShopifySyncStatus String?
  codShopifySyncedAt   DateTime?
  isExchange           Boolean            @default(false)
  originalOrderId      String?
  shipByDate           DateTime?
  sheetPushedAt        DateTime?          // When order was pushed to "Orders from COH" sheet
  partiallyCancelled   Boolean            @default(false)
  paymentConfirmedAt   DateTime?
  paymentConfirmedBy   String?
  paymentStatus        String?            @default("pending")
  channelOrderId       String?            // BT Order Id for channel imports (e.g., "16557031119098")
  customer             Customer?          @relation(fields: [customerId], references: [id])
  shopifyCache         ShopifyOrderCache? @relation(fields: [shopifyOrderId], references: [id])
  orderLines           OrderLine[]
  payments             OrderPayment[]     // Payment transactions for this order
  returnRequests       ReturnRequest[]    @relation("OriginalOrder")
  exchangeRequests     ReturnRequest[]    @relation("ExchangeOrder")
  originalOrder        Order?             @relation("ExchangeOriginalOrder", fields: [originalOrderId], references: [id])
  exchangeOrders       Order[]            @relation("ExchangeOriginalOrder")
  exchangeSourceLines  OrderLine[]        @relation("ExchangeOrderLine") // Lines that created this exchange order
  returnPrimeRequests  ReturnPrimeRequest[] // Return Prime requests linked to this order
  channelOrderLines    ChannelOrderLine[] // BT report analytics lines linked to this order
  financeInvoices      Invoice[]           @relation("InvoiceOrder")

  @@index([customerId])
  @@index([status])
  @@index([orderDate])
  @@index([isArchived])
  @@index([isExchange])
  @@index([originalOrderId])
  @@index([shipByDate])
  @@index([paymentStatus])
  @@index([paymentMethod, paymentStatus])
  @@index([status, orderDate])
  @@index([customerId, orderDate])
  @@index([status, isArchived])
  @@index([status, isArchived, orderDate])
  @@index([isArchived, releasedToShipped])
  @@index([isArchived, releasedToCancelled])
  @@index([isArchived, releasedToShipped, orderDate])
  @@index([customerId, paymentStatus])
  @@index([paymentMethod, codRemittedAt])
  @@index([channelOrderId])
}

// ============================================
// ORDER PAYMENTS
// ============================================

model OrderPayment {
  id             String   @id @default(uuid())
  orderId        String
  amount         Float    // Payment amount in ₹
  paymentMethod  String?  // cash, bank_transfer, upi, card, cheque, etc.
  reference      String?  // Transaction ID, UTR, receipt number, cheque number
  notes          String?  // Additional notes about this payment
  recordedById   String   // User who recorded this payment
  recordedAt     DateTime @default(now())
  createdAt      DateTime @default(now())

  order      Order @relation(fields: [orderId], references: [id], onDelete: Cascade)
  recordedBy User  @relation(fields: [recordedById], references: [id])

  @@index([orderId])
  @@index([recordedAt])
  @@index([orderId, recordedAt]) // Compound: payment history for order
  @@index([recordedById])        // FK index for user lookups
}

model OrderLine {
  id                   String              @id @default(uuid())
  orderId              String
  shopifyLineId        String?
  skuId                String
  qty                  Int
  unitPrice            Float
  lineStatus           String              @default("pending")
  allocatedAt          DateTime?
  pickedAt             DateTime?
  packedAt             DateTime?
  shippedAt            DateTime?
  deliveredAt          DateTime?
  inventoryTxnId       String?
  productionBatchId    String?
  notes                String?
  // Tracking fields (single source of truth for each line)
  awbNumber            String?
  courier              String?
  trackingStatus       String?
  lastTrackingUpdate   DateTime?
  lastScanAt           DateTime?
  lastScanLocation     String?
  lastScanStatus       String?
  courierStatusCode    String?
  deliveryAttempts     Int?
  expectedDeliveryDate DateTime?
  // RTO fields
  rtoInitiatedAt       DateTime?
  rtoReceivedAt        DateTime?
  rtoCondition         String?
  rtoInwardedAt        DateTime?
  rtoInwardedById      String?
  rtoNotes             String?
  // Customization
  customizedAt         DateTime?
  customizedById       String?
  isCustomized         Boolean             @default(false)
  isNonReturnable      Boolean             @default(false)
  originalSkuId        String?
  // Refund
  refundAmount         Float?
  refundNotes          String?
  refundReason         String?
  refundedAt           DateTime?
  // Custom shipping address (for multi-destination orders)
  shippingAddress      String?
  // Channel import fields
  channelFulfillmentStatus  String?    // Raw CSV status: processing, shipped, delivered, manifested, packed, cancelled
  channelItemId             String?    // BT Item ID for line-level matching on re-upload

  // === RETURN LIFECYCLE ===
  returnBatchNumber         String?       // Groups lines returned together, e.g., "64168/1", "64168/2"
  returnStatus              String?       // 'requested', 'pickup_scheduled', 'in_transit', 'received', 'complete', 'cancelled'
  returnQty                 Int?          // qty being returned (supports partial returns)
  returnRequestedAt         DateTime?
  returnRequestedById       String?

  // === PICKUP/LOGISTICS ===
  returnPickupType          String?       // 'arranged_by_us', 'customer_shipped'
  returnAwbNumber           String?
  returnCourier             String?
  returnPickupScheduledAt   DateTime?
  returnPickupAt            DateTime?
  returnReceivedAt          DateTime?
  returnReceivedById        String?

  // === CONDITION & QC ===
  returnCondition           String?       // 'good', 'damaged', 'defective', 'wrong_item', 'used'
  returnConditionNotes      String?

  // === REASON ===
  returnReasonCategory      String?       // 'fit_size', 'product_quality', 'product_different', 'wrong_item_sent', 'damaged_in_transit', 'changed_mind', 'other'
  returnReasonDetail        String?

  // === RESOLUTION ===
  returnResolution          String?       // 'refund', 'exchange', 'rejected'

  // === REFUND CALCULATION ===
  returnGrossAmount         Decimal?      @db.Decimal(10, 2)
  returnDiscountClawback    Decimal?      @db.Decimal(10, 2)
  returnDeductions          Decimal?      @db.Decimal(10, 2)
  returnDeductionNotes      String?
  returnNetAmount           Decimal?      @db.Decimal(10, 2)

  // === REFUND EXECUTION (enhances existing refund fields) ===
  returnRefundLinkSentAt    DateTime?
  returnRefundLinkId        String?
  returnRefundCompletedAt   DateTime?
  returnRefundMethod        String?       // 'payment_link', 'bank_transfer', 'store_credit'
  returnRefundReference     String?

  // === EXCHANGE ===
  returnExchangeOrderId     String?       // FK to the exchange Order
  returnExchangeSkuId       String?       // what they're exchanging to
  returnExchangePriceDiff   Decimal?      @db.Decimal(10, 2)

  // === MANUAL CLOSE (edge cases) ===
  returnClosedManually      Boolean?
  returnClosedManuallyAt    DateTime?
  returnClosedManuallyById  String?
  returnClosedReason        String?

  // === INTERNAL ===
  returnNotes               String?

  // === RETURN PRIME INTEGRATION ===
  returnPrimeRequestId        String?    // RP request ID
  returnPrimeRequestNumber    String?    // Human-readable (e.g., "RET625")
  returnPrimeStatus           String?    // approved, received, inspected, refunded, rejected, archived
  returnPrimeCreatedAt        DateTime?
  returnPrimeUpdatedAt        DateTime?
  returnPrimeSyncedAt         DateTime?  // Last sync TO Return Prime
  returnPrimeSyncError        String?    // For retry logic

  // Relations
  customizedBy         User?               @relation("CustomizedBy", fields: [customizedById], references: [id])
  order                Order               @relation(fields: [orderId], references: [id])
  productionBatch      ProductionBatch?    @relation(fields: [productionBatchId], references: [id])
  rtoInwardedBy        User?               @relation("RtoInwardedBy", fields: [rtoInwardedById], references: [id])
  sku                  Sku                 @relation(fields: [skuId], references: [id])
  repackingQueueItems  RepackingQueueItem[] @relation("OrderLineToRepacking")
  returnRequestLines   ReturnRequestLine[]
  returnRequestedBy    User?               @relation("ReturnRequestedBy", fields: [returnRequestedById], references: [id])
  returnReceivedBy     User?               @relation("ReturnReceivedBy", fields: [returnReceivedById], references: [id])
  returnClosedManuallyBy User?             @relation("ReturnClosedManuallyBy", fields: [returnClosedManuallyById], references: [id])
  returnExchangeOrder  Order?              @relation("ExchangeOrderLine", fields: [returnExchangeOrderId], references: [id])
  channelOrderLines    ChannelOrderLine[] // BT report analytics lines linked to this order line

  @@index([orderId])
  @@index([skuId])
  @@index([lineStatus])
  @@index([productionBatchId])
  @@index([lineStatus, orderId])
  @@index([rtoInwardedById])
  @@index([customizedById])
  @@index([awbNumber])
  @@index([skuId, rtoCondition])
  @@index([orderId, rtoCondition])
  @@index([lineStatus, skuId])
  @@index([skuId, lineStatus])
  @@index([orderId, lineStatus, shippedAt])
  @@index([awbNumber, courier])
  @@index([lineStatus, allocatedAt])
  @@index([trackingStatus])
  @@index([orderId, trackingStatus])
  // Return indexes
  @@index([returnBatchNumber])
  @@index([returnStatus])
  @@index([returnStatus, orderId])
  @@index([returnAwbNumber])
  @@index([returnRequestedAt])
  @@index([returnRequestedById])
  @@index([returnReceivedById])
  @@index([returnClosedManuallyById])
  @@index([returnExchangeOrderId])
  @@index([returnPrimeRequestId])
  @@index([returnPrimeStatus, returnPrimeUpdatedAt])  // Composite for status queries
}

model ReturnRequest {
  id                  String                @id @default(uuid())
  requestNumber       String                @unique
  requestType         String
  originalOrderId     String
  customerId          String?
  status              String                @default("pending_pickup")
  reasonCategory      String
  reasonDetails       String?
  resolutionNotes     String?
  createdAt           DateTime              @default(now())
  updatedAt           DateTime              @updatedAt
  exchangeOrderId     String?
  forwardDelivered    Boolean               @default(false)
  forwardDeliveredAt  DateTime?
  reverseReceived     Boolean               @default(false)
  reverseReceivedAt   DateTime?
  forwardShippedAt    DateTime?
  paymentAmount       Float?
  paymentCollectedAt  DateTime?
  refundAmount        Float?
  refundProcessedAt   DateTime?
  replacementValue    Float?
  resolution          String                @default("refund")
  returnValue         Float?
  reverseInTransitAt  DateTime?
  valueDifference     Float?
  repackingQueueItems RepackingQueueItem[]
  replacementItems    ReplacementItem[]
  customer            Customer?             @relation(fields: [customerId], references: [id])
  exchangeOrder       Order?                @relation("ExchangeOrder", fields: [exchangeOrderId], references: [id])
  originalOrder       Order                 @relation("OriginalOrder", fields: [originalOrderId], references: [id])
  lines               ReturnRequestLine[]
  shipping            ReturnShipping[]
  statusHistory       ReturnStatusHistory[]

  @@index([originalOrderId])
  @@index([customerId])
  @@index([status])
  @@index([resolution])
  @@index([exchangeOrderId])
  @@index([status, createdAt])
  @@index([customerId, status])
}

model ReturnRequestLine {
  id                  String        @id @default(uuid())
  requestId           String
  originalOrderLineId String?
  skuId               String
  qty                 Int
  exchangeSkuId       String?
  exchangeQty         Int?
  itemCondition       String?
  inspectionNotes     String?
  unitPrice           Float?
  exchangeSku         Sku?          @relation("ExchangeSku", fields: [exchangeSkuId], references: [id])
  originalOrderLine   OrderLine?    @relation(fields: [originalOrderLineId], references: [id])
  request             ReturnRequest @relation(fields: [requestId], references: [id])
  sku                 Sku           @relation("ReturnedSku", fields: [skuId], references: [id])

  @@index([requestId])
  @@index([skuId])
  @@index([skuId, itemCondition])
  @@index([originalOrderLineId]) // FK index for return processing
  @@index([exchangeSkuId])       // FK index for exchange lookups
}

model ReplacementItem {
  id        String        @id @default(uuid())
  requestId String
  skuId     String
  qty       Int
  unitPrice Float
  request   ReturnRequest @relation(fields: [requestId], references: [id])
  sku       Sku           @relation(fields: [skuId], references: [id])

  @@index([requestId])
  @@index([skuId])
}

model ReturnShipping {
  id                String        @id @default(uuid())
  requestId         String
  direction         String
  courier           String?
  awbNumber         String?
  pickupAddress     String?
  pickupScheduledAt DateTime?
  pickedUpAt        DateTime?
  receivedAt        DateTime?
  shippedAt         DateTime?
  deliveredAt       DateTime?
  status            String        @default("scheduled")
  notes             String?
  request           ReturnRequest @relation(fields: [requestId], references: [id])

  @@index([requestId])
}

model ReturnStatusHistory {
  id          String        @id @default(uuid())
  requestId   String
  fromStatus  String
  toStatus    String
  changedById String
  notes       String?
  createdAt   DateTime      @default(now())
  changedBy   User          @relation(fields: [changedById], references: [id])
  request     ReturnRequest @relation(fields: [requestId], references: [id])

  @@index([requestId])
  @@index([changedById]) // FK index for audit queries
}

model Feedback {
  id           String                @id @default(uuid())
  customerId   String?
  orderId      String?
  orderLineId  String?
  source       String
  feedbackType String
  status       String                @default("new")
  createdAt    DateTime              @default(now())
  updatedAt    DateTime              @updatedAt
  customer     Customer?             @relation(fields: [customerId], references: [id])
  content      FeedbackContent?
  media        FeedbackMedia[]
  productLinks FeedbackProductLink[]
  ratings      FeedbackRating[]
  tags         FeedbackTag[]

  @@index([customerId])
  @@index([status])
}

model FeedbackRating {
  id         String   @id @default(uuid())
  feedbackId String
  dimension  String
  score      Int
  feedback   Feedback @relation(fields: [feedbackId], references: [id])

  @@index([feedbackId]) // FK index
}

model FeedbackContent {
  id             String   @id @default(uuid())
  feedbackId     String   @unique
  title          String?
  body           String?
  pros           String?
  cons           String?
  wouldRecommend Boolean?
  feedback       Feedback @relation(fields: [feedbackId], references: [id])
}

model FeedbackMedia {
  id         String   @id @default(uuid())
  feedbackId String
  mediaType  String
  url        String
  caption    String?
  feedback   Feedback @relation(fields: [feedbackId], references: [id])

  @@index([feedbackId]) // FK index
}

model FeedbackProductLink {
  id          String   @id @default(uuid())
  feedbackId  String
  productId   String?
  variationId String?
  skuId       String?
  feedback    Feedback @relation(fields: [feedbackId], references: [id])
  sku         Sku?     @relation(fields: [skuId], references: [id])

  @@index([feedbackId])  // FK index
  @@index([productId])   // FK index for product lookup
  @@index([variationId]) // FK index for variation lookup
}

model FeedbackTag {
  id         String   @id @default(uuid())
  feedbackId String
  tag        String
  feedback   Feedback @relation(fields: [feedbackId], references: [id])

  @@index([feedbackId]) // FK index
}

model Tailor {
  id                String            @id @default(uuid())
  name              String            @unique // Prevent duplicate tailor names
  specializations   String?
  dailyCapacityMins Int               @default(480)
  isActive          Boolean           @default(true)
  createdAt         DateTime          @default(now())
  productionBatches ProductionBatch[]
  employee          Employee?
}

model ProductionBatch {
  id                String      @id @default(uuid())
  batchCode         String?     @unique
  batchDate         DateTime    @default(now())
  tailorId          String?
  skuId             String?     // Nullable for sample batches
  sampleCode        String?     @unique  // SAMPLE-01, SAMPLE-02, etc.
  sampleName        String?     // Description of sample item
  sampleColour      String?     // Colour for sample item
  sampleSize        String?     // Size for sample item
  qtyPlanned        Int
  qtyCompleted      Int         @default(0)
  priority          String
  sourceOrderLineId String?
  status            String      @default("planned")
  notes             String?
  createdAt         DateTime    @default(now())
  completedAt       DateTime?
  orderLines        OrderLine[]
  sku               Sku?        @relation(fields: [skuId], references: [id])  // Optional for samples
  tailor            Tailor?     @relation(fields: [tailorId], references: [id])

  @@index([skuId])
  @@index([tailorId])
  @@index([batchDate])
  @@index([status])
  @@index([batchDate, batchCode])
  @@index([skuId, status])
}

model RepackingQueueItem {
  id              String         @id @default(uuid())
  skuId           String
  qty             Int            @default(1)
  returnRequestId String?
  returnLineId    String?
  status          String         @default("pending")
  condition       String
  inspectionNotes String?
  writeOffReason  String?
  createdAt       DateTime       @default(now())
  processedAt     DateTime?
  processedById   String?
  qcComments      String?
  orderLineId     String?
  processedBy     User?          @relation("RepackingProcessor", fields: [processedById], references: [id])
  orderLine       OrderLine?     @relation("OrderLineToRepacking", fields: [orderLineId], references: [id])


  returnRequest   ReturnRequest? @relation(fields: [returnRequestId], references: [id])
  sku             Sku            @relation(fields: [skuId], references: [id])

  @@index([skuId])
  @@index([status])
  @@index([returnRequestId])
  @@index([orderLineId])
  @@index([skuId, status])
}

model WriteOffLog {
  id          String   @id @default(uuid())
  skuId       String
  qty         Int
  reason      String
  sourceType  String
  sourceId    String?
  notes       String?
  costValue   Float?
  createdById String
  createdAt   DateTime @default(now())
  createdBy   User     @relation("WriteOffCreator", fields: [createdById], references: [id])
  sku         Sku      @relation(fields: [skuId], references: [id])

  @@index([skuId])
  @@index([reason])
  @@index([createdAt])
}

model ShopifyInventoryCache {
  skuId                  String   @id
  shopifyInventoryItemId String
  availableQty           Int
  lastSynced             DateTime @default(now())
  sku                    Sku      @relation(fields: [skuId], references: [id])
}

model ShopifyProductCache {
  id              String    @id
  rawData         String
  title           String?
  handle          String?
  lastWebhookAt   DateTime  @default(now())
  webhookTopic    String?
  processedAt     DateTime?
  processingError String?
  createdAt       DateTime  @default(now())

  @@index([handle])
  @@index([processedAt])
  @@index([lastWebhookAt])
}

model SystemSetting {
  key       String   @id
  value     String
  updatedAt DateTime @updatedAt
}

/// Return policy settings (singleton - only one row)
model ReturnSettings {
  id                    String   @id @default("default")
  /// Days from delivery within which returns are accepted
  windowDays            Int      @default(14)
  /// Days before window expiry to show warning (e.g., 12 means 2 days left warning)
  windowWarningDays     Int      @default(12)
  /// Auto-reject returns after this many days (null = allow with override)
  autoRejectAfterDays   Int?
  /// Allow returns after window expires with manual override
  allowExpiredOverride  Boolean  @default(true)
  updatedAt             DateTime @updatedAt
  updatedById           String?
  updatedBy             User?    @relation(fields: [updatedById], references: [id])
}

model SyncJob {
  id              String    @id @default(uuid())
  jobType         String
  status          String    @default("pending")
  dateFilter      String?
  daysBack        Int?
  syncMode        String?
  staleAfterMins  Int?
  totalRecords    Int?
  processed       Int       @default(0)
  created         Int       @default(0)
  updated         Int       @default(0)
  skipped         Int       @default(0)
  errors          Int       @default(0)
  lastProcessedId String?
  currentBatch    Int       @default(0)
  errorLog        String?
  lastError       String?
  startedAt       DateTime?
  completedAt     DateTime?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  @@index([status])
  @@index([jobType])
  @@index([createdAt])
}

model ShopifyOrderCache {
  id                    String    @id
  rawData               String
  orderNumber           String?
  financialStatus       String?
  fulfillmentStatus     String?
  lastWebhookAt         DateTime  @default(now())
  webhookTopic          String?
  processedAt           DateTime?
  processingError       String?
  createdAt             DateTime  @default(now())
  customerNotes         String?
  discountCodes         String?
  paymentMethod         String?
  shippedAt             DateTime?
  shippingCity          String?
  shippingCountry       String?
  shippingState         String?
  tags                  String?
  trackingCompany       String?
  trackingNumber        String?
  trackingUrl           String?
  deliveredAt           DateTime?
  fulfillmentUpdatedAt  DateTime?
  shipmentStatus        String?
  processingLock        DateTime?
  billingCity           String?
  billingName           String?
  billingPhone          String?
  billingState          String?
  billingZip            String?
  buyerAcceptsMarketing Boolean?
  cancelReason          String?
  confirmationNumber    String?
  currency              String?
  customerEmail         String?
  customerFirstName     String?
  customerId            String?
  customerLastName      String?
  customerPhone         String?
  fulfillmentCount      Int?
  isConfirmed           Boolean?
  isTaxExempt           Boolean?
  isTest                Boolean?
  lineItemCount         Int?
  paymentGatewayNames   String?
  refundCount           Int?
  shippingAddress1      String?
  shippingAddress2      String?
  shippingCountryCode   String?
  shippingLatitude      Float?
  shippingLongitude     Float?
  shippingName          String?
  shippingPhone         String?
  shippingProvince      String?
  shippingProvinceCode  String?
  shippingZip           String?
  shopifyCancelledAt    DateTime?
  shopifyClosedAt       DateTime?
  shopifyCreatedAt      DateTime?
  shopifyOrderName      String?
  shopifyProcessedAt    DateTime?
  shopifyUpdatedAt      DateTime?
  sourceName            String?
  totalLineItemsPrice   Float?
  totalOutstanding      Float?
  totalShippingPrice    Float?
  totalPrice            Decimal?  @db.Decimal
  subtotalPrice         Decimal?  @db.Decimal
  totalTax              Decimal?  @db.Decimal
  totalDiscounts        Decimal?  @db.Decimal

  // Line item and order details (eliminates rawData parsing)
  lineItemsJson         String?   // [{id, sku, title, variant_title, price, quantity, discount_allocations}]
  shippingLinesJson     String?   // [{title, price}]
  taxLinesJson          String?   // [{title, price, rate}]
  noteAttributesJson    String?   // [{name, value}]

  // Missing billing address fields
  billingAddress1       String?
  billingAddress2       String?
  billingCountry        String?
  billingCountryCode    String?

  order                 Order?

  @@index([orderNumber])
  @@index([processedAt])
  @@index([lastWebhookAt])
}

model WebhookLog {
  id             String    @id @default(uuid())
  webhookId      String    @unique
  topic          String
  resourceId     String?
  source         String    @default("shopify")  // 'shopify' | 'returnprime'
  status         String    @default("received")
  responseCode   Int?
  processingTime Int?
  error          String?
  payload        String?   // Raw webhook JSON payload (truncated for large payloads)
  resultData     String?   // JSON of DB changes: {action, orderId, orderNumber, linesCreated, etc.}
  receivedAt     DateTime  @default(now())
  processedAt    DateTime?

  @@index([webhookId])
  @@index([topic])
  @@index([resourceId])
  @@index([receivedAt])
  @@index([source, topic])
}

// Stores raw iThink API responses for debugging (max 5 per AWB, rotated)
model TrackingApiResponse {
  id         String   @id @default(uuid())
  awbNumber  String
  source     String   // 'sync' | 'manual' | 'webhook'
  statusCode Int      // HTTP-like status (200 for success, 404 for not found, etc.)
  response   Json     // Full raw response from iThink API
  createdAt  DateTime @default(now())

  @@index([awbNumber])
  @@index([awbNumber, createdAt])
}

model FailedSyncItem {
  id          String    @id @default(uuid())
  itemType    String
  resourceId  String
  rawData     String?
  error       String
  retryCount  Int       @default(0)
  maxRetries  Int       @default(5)
  nextRetryAt DateTime?
  status      String    @default("pending")
  resolvedAt  DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@unique([itemType, resourceId])
  @@index([status])
  @@index([nextRetryAt])
  @@index([itemType])
}

model FabricReconciliation {
  id            String                     @id @default(uuid())
  reconcileDate DateTime                   @default(now())
  status        String                     @default("draft")
  notes         String?
  createdBy     String?
  createdAt     DateTime                   @default(now())
  updatedAt     DateTime                   @updatedAt
  items         FabricReconciliationItem[]

  @@index([status])
  @@index([createdAt])
}

model FabricReconciliationItem {
  id               String               @id @default(uuid())
  reconciliationId String
  fabricId         String
  systemQty        Float
  physicalQty      Float?
  variance         Float?
  adjustmentReason String?
  notes            String?
  txnId            String?              @unique
  fabric           Fabric               @relation(fields: [fabricId], references: [id])
  reconciliation   FabricReconciliation @relation(fields: [reconciliationId], references: [id], onDelete: Cascade)

  @@index([reconciliationId])
  @@index([fabricId])
}

model InventoryReconciliation {
  id            String                        @id @default(uuid())
  reconcileDate DateTime                      @default(now())
  status        String                        @default("draft")
  notes         String?
  createdBy     String?
  createdAt     DateTime                      @default(now())
  updatedAt     DateTime                      @updatedAt
  items         InventoryReconciliationItem[]

  @@index([status])
  @@index([createdAt])
}

model InventoryReconciliationItem {
  id               String                  @id @default(uuid())
  reconciliationId String
  skuId            String
  systemQty        Int
  physicalQty      Int?
  variance         Int?
  adjustmentReason String?
  notes            String?
  txnId            String?                 @unique
  reconciliation   InventoryReconciliation @relation(fields: [reconciliationId], references: [id], onDelete: Cascade)
  sku              Sku                     @relation(fields: [skuId], references: [id])

  @@index([reconciliationId])
  @@index([skuId])
}

model Pincode {
  id        String   @id @default(uuid())
  pincode   String   @unique
  district  String
  state     String
  region    String?
  division  String?
  createdAt DateTime @default(now())

  @@index([state])
  @@index([district])
}

// ============================================
// CATALOG MODELS (TrimItem, ServiceItem)
// ============================================

model TrimItem {
  id            String   @id @default(uuid())
  code          String   @unique // "BTN-SHELL-18L"
  name          String            // "Shell Button 18L"
  category      String            // "button", "zipper", "elastic", "label", "thread"
  description   String?

  costPerUnit   Float
  unit          String   @default("piece") // "piece", "meter", "spool"

  partyId       String?
  minOrderQty   Float?
  leadTimeDays  Int?

  isActive      Boolean  @default(true)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  party         Party?   @relation("TrimParty", fields: [partyId], references: [id])

  // BOM usages
  productBomTemplates ProductBomTemplate[]
  variationBomLines   VariationBomLine[]
  skuBomLines         SkuBomLine[]

  @@index([category])
  @@index([partyId])
}

model ServiceItem {
  id           String   @id @default(uuid())
  code         String   @unique // "PRINT-BLOCK-INDIGO"
  name         String            // "Block Print - Indigo Floral"
  category     String            // "printing", "embroidery", "washing", "dyeing"
  description  String?

  costPerJob   Float             // Base cost per unit processed
  costUnit     String   @default("per_piece") // "per_piece", "per_meter"

  partyId      String?
  leadTimeDays Int?

  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  party        Party?   @relation(fields: [partyId], references: [id])

  // BOM usages
  productBomTemplates ProductBomTemplate[]
  variationBomLines   VariationBomLine[]
  skuBomLines         SkuBomLine[]

  @@index([category])
  @@index([partyId])
}

// ============================================
// BOM COMPONENT TYPE DEFINITIONS
// ============================================

model ComponentType {
  id             String          @id @default(uuid())
  code           String          @unique // "FABRIC", "TRIM", "SERVICE"
  name           String                   // "Fabric", "Trim", "Service"
  trackInventory Boolean         @default(true) // false for SERVICE
  sortOrder      Int             @default(0)
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt

  roles          ComponentRole[]
}

model ComponentRole {
  id              String        @id @default(uuid())
  typeId          String
  code            String        // "main", "accent", "lining", "button", "print"
  name            String        // "Main Fabric", "Button", "Block Print"
  isRequired      Boolean       @default(false) // true for "main"
  allowMultiple   Boolean       @default(false) // true for some trims
  defaultQuantity Float?        // e.g., 7 for buttons
  defaultUnit     String?       // "meter", "piece", "job"
  sortOrder       Int           @default(0)
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  type            ComponentType @relation(fields: [typeId], references: [id])

  // BOM usages
  productBomTemplates ProductBomTemplate[]
  variationBomLines   VariationBomLine[]
  skuBomLines         SkuBomLine[]

  @@unique([typeId, code])
  @@index([typeId])
}

// ============================================
// 3-LEVEL BOM SYSTEM
// ============================================

// Level 1: Product BOM Template (structure + defaults)
model ProductBomTemplate {
  id              String   @id @default(uuid())
  productId       String
  roleId          String   // ComponentRole.id

  // Component (optional at product level - fabric colors set at variation)
  trimItemId      String?  // Trims CAN be set here (same buttons for all colors)
  serviceItemId   String?  // Services CAN be set here (same print for all colors)
  // Note: fabricColourId NOT here - fabrics are color-specific, set at variation

  // Default quantity (inherited by variations and SKUs)
  defaultQuantity Float    @default(1)
  quantityUnit    String   @default("unit") // "meter", "piece", "job"
  wastagePercent  Float    @default(0)
  notes           String?

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  product         Product       @relation(fields: [productId], references: [id], onDelete: Cascade)
  role            ComponentRole @relation(fields: [roleId], references: [id])
  trimItem        TrimItem?     @relation(fields: [trimItemId], references: [id])
  serviceItem     ServiceItem?  @relation(fields: [serviceItemId], references: [id])

  @@unique([productId, roleId]) // One template per role per product
  @@index([productId])
  @@index([roleId])
}

// Level 2: Variation BOM Override (fabric colors + overrides)
model VariationBomLine {
  id             String   @id @default(uuid())
  variationId    String
  roleId         String   // ComponentRole.id

  // Component overrides (null = inherit from product template)
  fabricColourId String?  // REQUIRED for fabric roles (color-specific)
  trimItemId     String?  // Override trim if this variant uses different one
  serviceItemId  String?  // Override service if this variant uses different one

  // Quantity override (null = inherit from product template)
  quantity       Float?
  wastagePercent Float?
  notes          String?

  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  variation      Variation     @relation(fields: [variationId], references: [id], onDelete: Cascade)
  role           ComponentRole @relation(fields: [roleId], references: [id])
  fabricColour   FabricColour? @relation(fields: [fabricColourId], references: [id])
  trimItem       TrimItem?     @relation(fields: [trimItemId], references: [id])
  serviceItem    ServiceItem?  @relation(fields: [serviceItemId], references: [id])

  @@unique([variationId, roleId]) // One line per role per variation
  @@index([variationId])
  @@index([roleId])
  @@index([fabricColourId])
}

// Level 3: SKU BOM Line (size-specific overrides)
model SkuBomLine {
  id             String   @id @default(uuid())
  skuId          String
  roleId         String   // ComponentRole.id

  // Component override (null = inherit from variation → product)
  fabricColourId String?  // Rare: specific SKU uses different fabric
  trimItemId     String?
  serviceItemId  String?

  // Quantity override (null = inherit from variation → product)
  quantity       Float?   // Common: XL uses more fabric
  wastagePercent Float?
  overrideCost   Float?   // Override catalog cost if needed
  notes          String?

  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  sku            Sku           @relation(fields: [skuId], references: [id], onDelete: Cascade)
  role           ComponentRole @relation(fields: [roleId], references: [id])
  fabricColour   FabricColour? @relation(fields: [fabricColourId], references: [id])
  trimItem       TrimItem?     @relation(fields: [trimItemId], references: [id])
  serviceItem    ServiceItem?  @relation(fields: [serviceItemId], references: [id])

  @@unique([skuId, roleId]) // One line per role per SKU
  @@index([skuId])
  @@index([roleId])
}

// ============================================
// FABRIC COLOUR TRANSACTIONS (NEW - replaces FabricTransaction)
// ============================================

model FabricColourTransaction {
  id              String        @id @default(uuid())
  fabricColourId  String
  txnType         String        // "inward" | "outward"
  qty             Float
  unit            String
  reason          String
  costPerUnit     Float?
  partyId         String?
  referenceId     String?
  notes           String?
  createdById     String
  createdAt       DateTime      @default(now())

  fabricColour    FabricColour  @relation(fields: [fabricColourId], references: [id])
  createdBy       User          @relation("FabricColourTxnCreator", fields: [createdById], references: [id])
  party           Party?        @relation("FabricColourTxnParty", fields: [partyId], references: [id])
  invoiceLine     FabricInvoiceLine? @relation("InvoiceLineTxn")

  @@index([fabricColourId])
  @@index([txnType])
  @@index([createdAt])
  @@index([fabricColourId, createdAt])
  @@index([fabricColourId, txnType]) // Optimizes balance aggregation queries
  @@index([partyId])
  @@index([createdById])
}

// ============================================
// FABRIC COLOUR RECONCILIATION (NEW - replaces FabricReconciliation)
// ============================================

model FabricColourReconciliation {
  id            String                            @id @default(uuid())
  reconcileDate DateTime                          @default(now())
  status        String                            @default("draft")
  notes         String?
  createdBy     String?
  createdAt     DateTime                          @default(now())
  updatedAt     DateTime                          @updatedAt
  items         FabricColourReconciliationItem[]

  @@index([status])
  @@index([createdAt])
}

model FabricColourReconciliationItem {
  id               String                      @id @default(uuid())
  reconciliationId String
  fabricColourId   String
  systemQty        Float
  physicalQty      Float?
  variance         Float?
  adjustmentReason String?
  notes            String?
  txnId            String?                     @unique
  fabricColour     FabricColour                @relation(fields: [fabricColourId], references: [id])
  reconciliation   FabricColourReconciliation  @relation(fields: [reconciliationId], references: [id], onDelete: Cascade)

  @@index([reconciliationId])
  @@index([fabricColourId])
}

// ============================================
// CHANNEL ORDER ANALYTICS (Marketplace Data)
// ============================================

/// Line-level data from BT reports for marketplace channels (Myntra, Ajio, Nykaa)
model ChannelOrderLine {
  id                  String    @id @default(uuid())

  // Channel & Order Identity
  channel             String                    // "myntra", "ajio", "nykaa"
  channelOrderId      String                    // BT Order Id (e.g., "16557031058666")
  channelRef          String?                   // Channel Ref UUID
  channelItemId       String                    // Item ID from BT

  // Order Info
  orderDate           DateTime
  orderType           String                    // "COD" or "Prepaid"
  financialStatus     String?                   // "Paid", "Cod"
  fulfillmentStatus   String?                   // "processing", "shipped", "delivered", "rto return pending", etc.

  // SKU Info
  skuCode             String                    // Maps to our SKU
  channelSkuCode      String?                   // Channel's SKU code
  skuTitle            String?
  quantity            Int                       @default(1)

  // Pricing (stored in paise for precision)
  mrp                 Int?                      // MRP in paise
  sellerPrice         Int?                      // Seller's Price
  buyerPrice          Int?                      // Buyer's Price (after discount)
  itemTotal           Int?                      // Item Total
  itemDiscount        Int?                      // Item Total Discount Value
  orderTotal          Int?                      // Order Total Amount

  // Tax
  taxPercent          Float?
  taxType             String?                   // "SGST/CGST" or "IGST"
  taxAmount           Int?                      // in paise

  // Shipping
  courierName         String?
  trackingNumber      String?

  // Dates
  dispatchByDate      DateTime?
  dispatchDate        DateTime?
  manifestedDate      DateTime?
  deliveryDate        DateTime?                 // Channel Delivery Date
  returnDate          DateTime?                 // BT Return Date
  channelReturnDate   DateTime?

  // Customer (denormalized for analytics)
  customerName        String?
  customerCity        String?
  customerState       String?
  customerZip         String?

  // Metadata
  invoiceNumber       String?
  batchNo             String?
  hsnCode             String?

  // ERP linkage
  orderId             String?                   // FK to ERP Order
  orderLineId         String?                   // FK to ERP OrderLine
  order               Order?    @relation(fields: [orderId], references: [id])
  orderLine           OrderLine? @relation(fields: [orderLineId], references: [id])

  // Import tracking
  importedAt          DateTime  @default(now())
  importBatchId       String?                   // Track which upload batch

  // Unique constraint: one line per channel + order + item
  @@unique([channel, channelOrderId, channelItemId])

  // Indexes for analytics queries
  @@index([channel])
  @@index([orderDate])
  @@index([channel, orderDate])
  @@index([fulfillmentStatus])
  @@index([skuCode])
  @@index([customerState])
  @@index([importBatchId])
  @@index([orderId])
  @@index([orderLineId])
}

/// Track import history for BT report uploads
model ChannelImportBatch {
  id            String    @id @default(uuid())
  channel       String                       // "myntra", "ajio", "nykaa", or "all"
  filename      String
  rowsTotal     Int
  rowsImported  Int
  rowsSkipped   Int
  rowsUpdated   Int
  errors        String?                       // JSON array of errors
  dateRangeStart DateTime?
  dateRangeEnd   DateTime?
  importedAt    DateTime  @default(now())
  importedBy    String?                       // User ID
  importType    String    @default("analytics")  // "analytics" | "order_import"
  ordersCreated Int       @default(0)
  ordersUpdated Int       @default(0)

  @@index([channel])
  @@index([importedAt])
}

// ============================================
// RETURN PRIME LOCAL CACHE
// ============================================

/// Stores Return Prime requests locally for faster dashboard loading and historical analytics
model ReturnPrimeRequest {
  id                    String    @id @default(uuid())

  // Return Prime identifiers
  rpRequestId           String    @unique  // Return Prime's request ID
  rpRequestNumber       String               // e.g., "RET9183" or "EXC9184"
  requestType           String               // "return" or "exchange"

  // Order reference
  shopifyOrderId        String?
  shopifyOrderName      String?              // e.g., "64377"
  orderId               String?              // COH-ERP Order ID if linked

  // Customer info
  customerName          String?
  customerEmail         String?
  customerPhone         String?
  customerAddress       Json?                // Full address object
  customerBank          Json?                // Bank details for refunds

  // Status flags with timestamps
  isApproved            Boolean   @default(false)
  approvedAt            DateTime?
  approvedComment       String?

  isReceived            Boolean   @default(false)
  receivedAt            DateTime?
  receivedComment       String?

  isInspected           Boolean   @default(false)
  inspectedAt           DateTime?
  inspectedComment      String?

  isRefunded            Boolean   @default(false)
  refundedAt            DateTime?

  isRejected            Boolean   @default(false)
  rejectedAt            DateTime?
  rejectedComment       String?

  isArchived            Boolean   @default(false)
  archivedAt            DateTime?

  // Line items stored as JSON array
  lineItems             Json      @default("[]")
  lineItemCount         Int       @default(0)

  // Computed values for fast queries
  totalValue            Decimal   @default(0) @db.Decimal(10, 2)
  primaryReason         String?              // First line item's reason

  // Return Prime timestamps
  rpCreatedAt           DateTime             // When created in Return Prime
  rpUpdatedAt           DateTime?            // Last update in Return Prime

  // Sync tracking
  syncedAt              DateTime  @default(now())
  rawData               Json?                // Full API response for reference

  // Timestamps
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  // Relations
  order                 Order?    @relation(fields: [orderId], references: [id])

  @@index([rpRequestNumber])
  @@index([shopifyOrderId])
  @@index([shopifyOrderName])
  @@index([requestType])
  @@index([rpCreatedAt])
  @@index([isApproved, isReceived, isRefunded])
  @@index([customerEmail])
  @@index([syncedAt])
}

model MonthlyStockSnapshot {
  id               String   @id @default(uuid())
  skuId            String
  month            DateTime // 1st of month in UTC (e.g. 2026-01-01T00:00:00Z)
  openingStock     Int
  totalInward      Int
  totalOutward     Int
  closingStock     Int      // = opening + inward - outward
  inwardBreakdown  Json     @default("{}")  // {"production": 50, "return_receipt": 5}
  outwardBreakdown Json     @default("{}")  // {"sale": 40, "damage": 1}
  computedAt       DateTime @default(now())
  sku              Sku      @relation(fields: [skuId], references: [id])

  @@unique([skuId, month])
  @@index([month])
  @@index([skuId])
}

// ============================================
// FABRIC INVOICES (AI-parsed supplier invoices)
// ============================================

/// Stores a supplier fabric invoice (PDF/photo) with AI-extracted data
model FabricInvoice {
  id              String   @id @default(uuid())

  // Invoice details (AI-extracted + user-corrected)
  invoiceNumber   String?
  invoiceDate     DateTime?
  partyId         String?
  supplierName    String?              // Raw name from invoice (before matching)

  // Totals
  subtotal        Float?
  gstAmount       Float?
  totalAmount     Float?

  // Original file stored as binary (invoices are small, no S3 needed)
  fileData        Bytes
  fileName        String
  fileMimeType    String               // "application/pdf", "image/jpeg", etc.
  fileSizeBytes   Int

  // Status: draft → confirmed → cancelled
  status          String   @default("draft")

  // AI metadata
  aiRawResponse   Json?                // Full AI response for debugging
  aiModel         String?              // e.g. "claude-sonnet-4-5-20250929"
  aiConfidence    Float?               // 0-1 overall confidence score

  // Tracking
  createdById     String
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  party           Party?    @relation("FabricInvoiceParty", fields: [partyId], references: [id])
  createdBy       User      @relation("FabricInvoiceCreator", fields: [createdById], references: [id])
  lines           FabricInvoiceLine[]
  financeInvoice  Invoice?  @relation("FabricInvoiceBridge")

  @@index([status])
  @@index([partyId])
  @@index([createdAt])
  @@index([invoiceNumber])
}

/// Individual line item on a fabric invoice
model FabricInvoiceLine {
  id              String   @id @default(uuid())
  invoiceId       String

  // Parsed data
  description     String?              // Raw description from invoice
  hsnCode         String?
  qty             Float?
  unit            String?              // "meter", "kg", "yard"
  rate            Float?               // Per-unit rate
  amount          Float?               // qty * rate
  gstPercent      Float?
  gstAmount       Float?

  // Matching
  fabricColourId  String?              // Matched FabricColour
  matchedTxnId    String?  @unique     // Matched existing FabricColourTransaction (1:1)
  matchType       String?              // "auto_matched" | "manual_matched" | "new_entry"

  // Relations
  invoice         FabricInvoice         @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  fabricColour    FabricColour?         @relation("InvoiceLineFabricColour", fields: [fabricColourId], references: [id])
  matchedTxn      FabricColourTransaction? @relation("InvoiceLineTxn", fields: [matchedTxnId], references: [id])

  @@index([invoiceId])
  @@index([fabricColourId])
}

// ============================================
// FINANCE: LEDGER, INVOICES, PAYMENTS
// ============================================

/// Chart of accounts — seeded from config, balances maintained by DB trigger
model LedgerAccount {
  id        String   @id @default(uuid())
  code      String   @unique
  name      String
  type      String   // asset, liability, income, direct_cost, expense, equity
  balance   Float    @default(0) // Maintained by DB trigger on LedgerEntryLine changes
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  lines LedgerEntryLine[]

  @@index([type])
}

/// A journal entry (header) — groups debit/credit lines that must balance
model LedgerEntry {
  id           String   @id @default(uuid())
  entryDate    DateTime
  period       String   // "YYYY-MM" — which P&L month this belongs to (accrual basis)
  description  String
  sourceType   String   // fabric_inward, production_inward, invoice_confirmed, manual, etc.
  sourceId     String?  // FK to originating record (for idempotency + tracing)
  isReversed   Boolean  @default(false)
  reversedById String?  // FK to the reversal entry
  notes        String?
  createdById  String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  createdBy  User          @relation("LedgerEntryCreator", fields: [createdById], references: [id])
  reversedBy LedgerEntry?  @relation("LedgerEntryReversal", fields: [reversedById], references: [id])
  reversals  LedgerEntry[] @relation("LedgerEntryReversal")
  lines      LedgerEntryLine[]
  invoice    Invoice?      @relation("InvoiceLedgerEntry")
  payment    Payment?      @relation("PaymentLedgerEntry")
  bankTransaction BankTransaction? @relation("BankTxnLedgerEntry")

  @@unique([sourceType, sourceId]) // Idempotency: one entry per source event
  @@index([entryDate])
  @@index([period])
  @@index([sourceType])
  @@index([createdAt])
}

/// Individual debit or credit line within a journal entry
model LedgerEntryLine {
  id          String  @id @default(uuid())
  entryId     String
  accountId   String
  debit       Float   @default(0)
  credit      Float   @default(0)
  description String?

  entry   LedgerEntry   @relation(fields: [entryId], references: [id], onDelete: Cascade)
  account LedgerAccount @relation(fields: [accountId], references: [id])

  @@index([entryId])
  @@index([accountId])
}

/// Source document for "money is owed" — vendor bills or customer receivables
model Invoice {
  id               String    @id @default(uuid())
  invoiceNumber    String?
  type             String    // payable, receivable
  category         String    // fabric, trims, service, rent, salary, etc.
  status           String    @default("draft") // draft, confirmed, partially_paid, paid, cancelled

  invoiceDate      DateTime?
  dueDate          DateTime?
  billingPeriod    String?   // "YYYY-MM" — which month this bill covers (for accrual P&L)

  // Counterparty (one of these)
  partyId          String?
  customerId       String?
  counterpartyName String?   // Fallback if no linked entity

  // Amounts
  subtotal         Float?
  gstAmount        Float?
  tdsAmount        Float?    @default(0)
  totalAmount      Float
  paidAmount       Float     @default(0)
  balanceDue       Float     @default(0)

  // Linked records
  orderId          String?
  fabricInvoiceId  String?   @unique // Optional 1:1 bridge to FabricInvoice

  // File attachment (stored as binary, same pattern as FabricInvoice)
  fileData         Bytes?
  fileName         String?
  fileMimeType     String?
  fileSizeBytes    Int?

  // AI parsing metadata (for future AI upload)
  aiRawResponse    Json?
  aiModel          String?
  aiConfidence     Float?

  // Google Drive sync
  driveFileId      String?
  driveUrl         String?
  driveUploadedAt  DateTime?

  // Ledger link
  ledgerEntryId    String?   @unique

  // Tracking
  notes            String?
  createdById      String
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  // Relations
  party         Party?         @relation("InvoiceParty", fields: [partyId], references: [id])
  customer      Customer?      @relation("InvoiceCustomer", fields: [customerId], references: [id])
  order         Order?         @relation("InvoiceOrder", fields: [orderId], references: [id])
  fabricInvoice FabricInvoice? @relation("FabricInvoiceBridge", fields: [fabricInvoiceId], references: [id])
  ledgerEntry   LedgerEntry?   @relation("InvoiceLedgerEntry", fields: [ledgerEntryId], references: [id])
  createdBy     User           @relation("InvoiceCreator", fields: [createdById], references: [id])
  lines         InvoiceLine[]
  matchedPayments PaymentInvoice[]
  payrollSlip   PayrollSlip?     @relation("PayrollSlipInvoice")
  bankTransactions BankTransaction[] @relation("BankTxnInvoice")

  @@index([type])
  @@index([status])
  @@index([category])
  @@index([partyId])
  @@index([customerId])
  @@index([orderId])
  @@index([createdAt])
  @@index([invoiceNumber])
  @@index([partyId, invoiceNumber, invoiceDate])
}

/// Line item on an invoice
model InvoiceLine {
  id          String  @id @default(uuid())
  invoiceId   String
  description String?
  hsnCode     String?
  qty         Float?
  unit        String?
  rate        Float?
  amount      Float?
  gstPercent  Float?
  gstAmount   Float?

  invoice Invoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  @@index([invoiceId])
}

/// Record of actual money moving
model Payment {
  id              String   @id @default(uuid())
  referenceNumber String?
  direction       String   // outgoing, incoming
  method          String   // bank_transfer, upi, cash, etc.
  status          String   @default("confirmed") // draft, confirmed, cancelled

  amount          Float
  matchedAmount   Float    @default(0)
  unmatchedAmount Float    @default(0)

  paymentDate     DateTime

  // Counterparty (one of these)
  partyId          String?
  customerId       String?
  counterpartyName String?

  // File attachment
  fileData      Bytes?
  fileName      String?
  fileMimeType  String?
  fileSizeBytes Int?

  // Google Drive sync
  driveFileId      String?
  driveUrl         String?
  driveUploadedAt  DateTime?

  // Ledger link
  ledgerEntryId String? @unique

  // Tracking
  notes       String?
  createdById String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  party       Party?       @relation("PaymentParty", fields: [partyId], references: [id])
  customer    Customer?    @relation("PaymentCustomer", fields: [customerId], references: [id])
  ledgerEntry LedgerEntry? @relation("PaymentLedgerEntry", fields: [ledgerEntryId], references: [id])
  createdBy   User         @relation("PaymentCreator", fields: [createdById], references: [id])
  matchedInvoices PaymentInvoice[]
  bankTransaction BankTransaction? @relation("BankTxnPayment")

  @@index([direction])
  @@index([method])
  @@index([status])
  @@index([partyId])
  @@index([customerId])
  @@index([paymentDate])
  @@index([createdAt])
}

/// Many-to-many join: which payments cover which invoices
model PaymentInvoice {
  id         String   @id @default(uuid())
  paymentId  String
  invoiceId  String
  amount     Float    // How much of this payment goes to this invoice
  notes      String?
  matchedAt  DateTime @default(now())
  matchedById String

  payment   Payment @relation(fields: [paymentId], references: [id], onDelete: Cascade)
  invoice   Invoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  matchedBy User    @relation("PaymentInvoiceMatcher", fields: [matchedById], references: [id])

  @@unique([paymentId, invoiceId])
  @@index([paymentId])
  @@index([invoiceId])
}

// ============================================
// WORKER RUN HISTORY
// ============================================

/// Persists every background worker run for visibility into "did anything break overnight?"
model WorkerRun {
  id           String    @id @default(uuid())
  workerName   String    // "tracking_sync", "shopify_sync", etc.
  status       String    @default("running") // "running" | "completed" | "failed"
  startedAt    DateTime
  completedAt  DateTime?
  durationMs   Int?
  result       Json?     // The worker's SyncResult object
  error        String?   // Error message if failed
  triggeredBy  String    @default("scheduled") // "scheduled" | "manual" | "startup"
  createdAt    DateTime  @default(now())

  @@index([workerName, startedAt])
  @@index([createdAt])
}

// ============================================
// PAYROLL & EMPLOYEE MANAGEMENT
// ============================================

/// Employee record with salary structure and statutory details
model Employee {
  id               String    @id @default(uuid())
  name             String    @unique
  employeeCode     String?
  phone            String?
  email            String?

  dateOfJoining    DateTime?
  dateOfExit       DateTime?

  department       String    // production, office
  designation      String?

  /// Basic salary — HRA (40%), Other (60%), Gross (2x basic) are always computed
  basicSalary      Float

  /// Statutory deduction flags
  pfApplicable     Boolean   @default(false)
  esicApplicable   Boolean   @default(false)
  ptApplicable     Boolean   @default(false)

  /// Bank details
  bankAccountName   String?
  bankAccountNumber String?
  bankIfsc          String?
  bankName          String?

  /// Statutory IDs
  pan              String?
  aadhaar          String?
  uan              String?
  esicNumber       String?

  /// Links to other models
  partyId          String?   @unique
  tailorId         String?   @unique

  isActive         Boolean   @default(true)
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  party            Party?    @relation(fields: [partyId], references: [id])
  tailor           Tailor?   @relation(fields: [tailorId], references: [id])
  payrollSlips     PayrollSlip[]

  @@index([department])
  @@index([isActive])
}

/// Monthly payroll batch header
model PayrollRun {
  id                String    @id @default(uuid())
  month             Int       // 1-12
  year              Int       // e.g. 2026
  status            String    @default("draft") // draft, confirmed, cancelled

  /// Totals (computed from slips)
  totalGross        Float     @default(0)
  totalDeductions   Float     @default(0)
  totalNetPay       Float     @default(0)
  totalEmployerCost Float     @default(0)
  employeeCount     Int       @default(0)

  confirmedAt       DateTime?
  confirmedById     String?
  notes             String?
  createdById       String
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  confirmedBy       User?     @relation("PayrollRunConfirmer", fields: [confirmedById], references: [id])
  createdBy         User      @relation("PayrollRunCreator", fields: [createdById], references: [id])
  slips             PayrollSlip[]

  @@unique([month, year])
  @@index([status])
}

/// Per-employee payroll calculation within a run
model PayrollSlip {
  id                    String   @id @default(uuid())
  payrollRunId          String
  employeeId            String

  /// Days
  daysInMonth           Int
  payableDays           Float    // Can be fractional (e.g. 26.5)
  isManualDays          Boolean  @default(false)

  /// Fixed components (from salary structure at time of run)
  basicFixed            Float
  hraFixed              Float
  otherAllowanceFixed   Float
  grossFixed            Float

  /// Earned (pro-rated by payable days)
  basicEarned           Float
  hraEarned             Float
  otherAllowanceEarned  Float
  grossEarned           Float

  /// Employee deductions
  pfEmployee            Float    @default(0)
  esicEmployee          Float    @default(0)
  professionalTax       Float    @default(0)
  advances              Float    @default(0)
  otherDeductions       Float    @default(0)
  totalDeductions       Float    @default(0)

  /// Net pay
  netPay                Float    @default(0)

  /// Employer contributions
  pfEmployer            Float    @default(0)
  pfAdmin               Float    @default(0)
  esicEmployer          Float    @default(0)
  totalEmployerCost     Float    @default(0)
  costToCompany         Float    @default(0)

  /// Finance link
  invoiceId             String?  @unique

  /// External payroll system data (full register row from RazorpayPayroll etc.)
  registerData          Json?

  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  payrollRun            PayrollRun @relation(fields: [payrollRunId], references: [id], onDelete: Cascade)
  employee              Employee   @relation(fields: [employeeId], references: [id])
  invoice               Invoice?   @relation("PayrollSlipInvoice", fields: [invoiceId], references: [id])

  @@unique([payrollRunId, employeeId])
  @@index([payrollRunId])
  @@index([employeeId])
}

// ============================================
// BANK IMPORT V2
// ============================================

/// Raw bank transaction row — imported from CSV/hardcoded data, then categorized, then optionally posted to ledger
model BankTransaction {
  id                String    @id @default(uuid())
  bank              String    // "hdfc" | "razorpayx" | "hdfc_cc" | "icici_cc"
  txnHash           String    @unique // SHA-256 hash for dedup
  rawData           Json      // Original CSV row as-is
  txnDate           DateTime
  amount            Float
  direction         String    // "debit" | "credit" — from bank's perspective
  narration         String?
  reference         String?   // HDFC ref, RazorpayX payout_id, etc.
  utr               String?
  closingBalance    Float?

  // Categorization (null until categorized)
  counterpartyName  String?
  debitAccountCode  String?
  creditAccountCode String?
  category          String?
  partyId           String?
  matchedInvoiceId  String?

  // AP routing — preserves categorizer's intent even when posted to AP
  intendedDebitAccount String?  // The expense account from categorization
  postingType          String?  // 'single_step' or 'two_step'

  // Status: imported → categorized → posted | skipped | legacy_posted
  status            String    @default("imported")
  skipReason        String?

  // Links to existing records
  ledgerEntryId     String?   @unique
  paymentId         String?   @unique
  legacySourceId    String?   // Old sourceId format for audit matching

  // Batch tracking
  batchId           String?

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  // Relations
  party             Party?        @relation("BankTxnParty", fields: [partyId], references: [id])
  matchedInvoice    Invoice?      @relation("BankTxnInvoice", fields: [matchedInvoiceId], references: [id])
  ledgerEntry       LedgerEntry?  @relation("BankTxnLedgerEntry", fields: [ledgerEntryId], references: [id])
  payment           Payment?      @relation("BankTxnPayment", fields: [paymentId], references: [id])
  batch             BankImportBatch? @relation(fields: [batchId], references: [id])

  @@index([bank, status])
  @@index([txnDate])
  @@index([utr])
  @@index([legacySourceId])
  @@index([batchId])
}

/// Batch metadata for a single CSV import run
model BankImportBatch {
  id              String    @id @default(uuid())
  bank            String
  fileName        String
  rowCount        Int
  newCount        Int
  skippedCount    Int
  totalDebits     Float
  totalCredits    Float
  openingBalance  Float?
  closingBalance  Float?
  balanceMatched  Boolean?
  createdAt       DateTime  @default(now())

  transactions    BankTransaction[]
}
