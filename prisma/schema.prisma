generator client {
  provider = "prisma-client-js"
}

generator kysely {
  provider     = "prisma-kysely"
  output       = "../server/src/db"
  fileName     = "types.ts"
  enumFileName = "enums.ts"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Role {
  id          String   @id @default(uuid())
  name        String   @unique
  displayName String
  description String?
  permissions Json
  isBuiltIn   Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  users       User[]
}

model User {
  id                    String                   @id @default(uuid())
  email                 String                   @unique
  phone                 String?                  @unique
  password              String
  name                  String
  role                  String                   @default("staff")
  isActive              Boolean                  @default(true)
  createdAt             DateTime                 @default(now())
  updatedAt             DateTime                 @updatedAt
  mustChangePassword    Boolean                  @default(false)
  roleId                String?
  tokenVersion          Int                      @default(0)
  extraAccess           Json                     @default("[]") // Array of AccessFeature strings for exceptions beyond role
  userRole              Role?                    @relation(fields: [roleId], references: [id])
  permissionOverrides   UserPermissionOverride[]
  gridPreferences       UserGridPreference[]
  inventoryTransactions InventoryTransaction[]
  // NOTE: fabricTransactions removed - use fabricColourTransactions
  fabricColourTransactions FabricColourTransaction[] @relation("FabricColourTxnCreator")
  processedRepackItems  RepackingQueueItem[]     @relation("RepackingProcessor")
  createdWriteOffs      WriteOffLog[]            @relation("WriteOffCreator")
  rtoInwardedLines      OrderLine[]              @relation("RtoInwardedBy")
  customizedLines       OrderLine[]              @relation("CustomizedBy")
  recordedPayments      OrderPayment[]           // Payments recorded by this user
  // Return tracking relations
  returnRequestedLines  OrderLine[]              @relation("ReturnRequestedBy")
  returnReceivedLines   OrderLine[]              @relation("ReturnReceivedBy")
  returnClosedManuallyLines OrderLine[]          @relation("ReturnClosedManuallyBy")
  // Settings updates
  returnSettingsUpdates ReturnSettings[]
  // Finance relations
  financeInvoices       Invoice[]        @relation("InvoiceCreator")
  financePayments       Payment[]        @relation("PaymentCreator")
  allocationMatches     Allocation[]     @relation("AllocationMatcher")
  ledgerEntries         LedgerEntry[]    @relation("LedgerEntryCreator")
  payrollRunsCreated    PayrollRun[]     @relation("PayrollRunCreator")
  payrollRunsConfirmed  PayrollRun[]     @relation("PayrollRunConfirmer")
  // Changelog relations
  transactionTypeChangeLogs TransactionTypeChangeLog[] @relation("TxnTypeChangeUser")
  partyChangeLogs           PartyChangeLog[]           @relation("PartyChangeUser")
  leaveRecordsCreated       LeaveRecord[]              @relation("LeaveRecordCreator")
  salaryRevisions           SalaryRevision[]           @relation("SalaryRevisionCreator")
  fabricStockCounts         FabricStockCount[]         @relation("FabricStockCountCreator")

  @@index([roleId])
}

model UserPermissionOverride {
  id         String   @id @default(uuid())
  userId     String
  permission String
  granted    Boolean
  createdAt  DateTime @default(now())
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, permission])
  @@index([userId])
}

model UserGridPreference {
  id             String    @id @default(uuid())
  userId         String
  gridId         String
  visibleColumns String    // JSON array of visible column IDs
  columnOrder    String    // JSON array of column IDs in display order
  columnWidths   String    // JSON object of columnId -> width mappings
  adminVersion   DateTime? // Tracks which admin defaults user has acknowledged
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, gridId])
  @@index([userId])
  @@index([gridId])
}

/// 1:1 with Shopify product. Each color of a design is a separate Product.
/// Sibling colors share the same name but are NOT linked in the DB.
/// Shopify groups siblings via `custom.product_variants` metafield (list of product GIDs).
model Product {
  id                       String      @id @default(uuid())
  name                     String
  styleCode                String?
  category                 String
  garmentGroup             String      @default("tops") // tops | bottoms | dresses | sets | accessories
  productType              String
  gender                   String      @default("unisex")
  googleProductCategoryId  Int?        // Google/Meta product taxonomy ID (e.g. 212 = Shirts & Tops)
  attributes               Json?       // Structured product attributes — see productAttributesSchema in shared/src/config/productTaxonomy.ts
  // NOTE: fabricTypeId removed - fabric info comes from variation BOM lines
  baseProductionTimeMins   Int         @default(60)
  defaultFabricConsumption Float?
  description              String?
  erpDescription           String?
  erpDescriptionHistory    Json?       // Array of {version, text, createdAt, source}
  erpSeoTitle              String?     // SEO meta title (50-60 chars ideal)
  erpSeoDescription        String?     // SEO meta description (150-160 chars ideal)
  imageUrl                 String?
  notes                    Json?       // Array of {id, text, createdAt, updatedAt}
  status                   String      @default("draft") // draft | active | archived
  isActive                 Boolean     @default(true)
  isReturnable             Boolean     @default(true)
  nonReturnableReason      String?     // 'sale_item', 'hygiene', 'custom_made', etc.
  createdAt                DateTime    @default(now())
  updatedAt                DateTime    @updatedAt
  shopifyProductId         String?     @unique // 1:1 with Shopify product
  shopifyHandle            String?
  exchangeCount            Int         @default(0)
  returnCount              Int         @default(0)
  writeOffCount            Int         @default(0)
  hsnCode                  String?     // HSN/SAC code for GST (default '6109' for knitted apparel)
  shopifyProductIds        String[]    @default([]) // LEGACY — stale, not used. Was old multi-color grouping attempt. Safe to clear.
  variations               Variation[]
  bomTemplates             ProductBomTemplate[] // BOM structure for this product

  @@index([category])
  @@index([garmentGroup])
  @@index([shopifyHandle])
  @@index([name])
  @@index([styleCode])
}

/// In the current 1:1 sync, each Product has exactly ONE Variation (holds color name).
/// shopifySourceProductId duplicates Product.shopifyProductId in 1:1 mode.
/// Shopify "Product" (one color) = ERP Product + Variation. Shopify "Variant" (size) = ERP Sku.
model Variation {
  id                     String  @id @default(uuid())
  productId              String
  colorName              String
  standardColor          String?
  colorHex               String?
  // NOTE: fabricId/fabricColourId removed - fabric assignment via BOM (VariationBomLine.fabricColourId)
  imageUrl               String?
  isActive               Boolean @default(true)
  hasLining              Boolean @default(false)
  bomCost                Float?   // Computed total BOM cost (sum of SKU bomCosts)
  shopifySourceProductId String?  // Same as parent Product.shopifyProductId in 1:1 mode
  shopifySourceHandle    String?
  skus                   Sku[]
  product                Product @relation(fields: [productId], references: [id])
  bomLines               VariationBomLine[] // BOM overrides for this variation (fabric assigned here)

  @@unique([productId, colorName])
  @@index([productId])
  @@index([shopifySourceProductId])
}

model Sku {
  id                     String                        @id @default(uuid())
  skuCode                String                        @unique
  variationId            String
  size                   String
  mrp                    Float
  sellingPrice           Float?                        // Shopify selling price (null = same as MRP, i.e. not discounted)
  currentBalance         Int                           @default(0) // Materialized balance: updated atomically on every transaction
  targetStockQty         Int                           @default(10)
  targetStockMethod      String                        @default("day14")
  isActive               Boolean                       @default(true)
  shopifyInventoryItemId String?
  shopifyVariantId       String?
  exchangeCount          Int                           @default(0)
  returnCount            Int                           @default(0)
  writeOffCount          Int                           @default(0)
  customizationCount     Int                           @default(0)
  customizationNotes     String?
  customizationType      String?
  customizationValue     String?
  isCustomSku            Boolean                       @default(false)
  linkedOrderLineId      String?                       @unique
  parentSkuId            String?
  bomCost                Float?   // Computed total BOM cost (fabric + trims + services)
  feedbackProductLinks   FeedbackProductLink[]
  reconciliationItems    InventoryReconciliationItem[]
  inventoryTransactions  InventoryTransaction[]
  orderLines             OrderLine[]
  productionBatches      ProductionBatch[]
  repackingQueueItems    RepackingQueueItem[]
  shopifyInventoryCache  ShopifyInventoryCache?
  parentSku              Sku?                          @relation("CustomSkus", fields: [parentSkuId], references: [id])
  customSkus             Sku[]                         @relation("CustomSkus")
  variation              Variation                     @relation(fields: [variationId], references: [id])
  writeOffLogs           WriteOffLog[]
  bomLines               SkuBomLine[]                  // NEW: BOM overrides for this SKU
  monthlySnapshots       MonthlyStockSnapshot[]

  @@index([variationId])
  @@index([parentSkuId])
  @@index([isCustomSku])
  @@index([shopifyVariantId])     // Shopify sync: variant lookup
  @@index([shopifyInventoryItemId]) // Shopify inventory sync lookup
}

model CostConfig {
  id                     String   @id @default(uuid())
  laborRatePerMin        Float    @default(2.50)
  defaultPackagingCost   Float    @default(50)
  lastUpdated            DateTime @default(now())
  gstRateAbove           Float    @default(18)
  gstRateBelow           Float    @default(5)
  gstThreshold           Float    @default(2500)
  // Monthly overhead costs for P&L analysis
  monthlyLaborOverhead   Float?   // Default: Rs 15,00,000
  monthlyMarketingBudget Float?   // Default: Rs 15,00,000
}

// ============================================
// MATERIAL HIERARCHY (3-tier system)
// ============================================
// NOTE: FabricType model removed - replaced by Material model

// Level 1: Base fiber/material (replaces FabricType conceptually)
model Material {
  id          String   @id @default(uuid())
  name        String   @unique // "Linen", "Pima Cotton", "Cotton", "Utility"
  description String?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  fabrics     Fabric[] @relation("MaterialFabrics")
}

// Level 3: Color variant (the actual inventory item)
model FabricColour {
  id             String   @id @default(uuid())
  fabricId       String
  code           String?  @unique // Short reference code e.g. "LIN-60L-NVY"
  colourName     String   // "Navy Blue", "Rust", "Natural"
  standardColour String?  // Normalized: "blue", "red", "beige"
  colourHex      String?

  // Cost/supply overrides (null = inherit from Fabric)
  costPerUnit    Float?
  partyId        String?
  leadTimeDays   Int?
  minOrderQty    Float?

  currentBalance Float    @default(0) // Materialized balance: updated atomically by DB trigger
  isOutOfStock   Boolean  @default(false) // Manual flag to mark fabric as out of stock

  isActive       Boolean  @default(true)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  fabric         Fabric   @relation("FabricColours", fields: [fabricId], references: [id])
  party          Party?    @relation("FabricColourParty", fields: [partyId], references: [id])

  // BOM usages (fabric assignment via these tables)
  variationBomLines VariationBomLine[]
  skuBomLines       SkuBomLine[]

  // Transactions and reconciliation
  // NOTE: Direct variation link removed - use variationBomLines for fabric->variation
  transactions             FabricColourTransaction[]
  reconciliationItems      FabricColourReconciliationItem[]
  stockCounts              FabricStockCount[]
  invoiceLines             InvoiceLine[]       @relation("FinanceInvoiceLineFabricColour")

  @@unique([fabricId, colourName])
  @@index([fabricId])
  @@index([partyId])
  @@index([fabricId, isActive]) // Composite index for active colours per fabric
}

model Fabric {
  id                  String                     @id @default(uuid())
  // NOTE: fabricTypeId removed - fabric now links directly to Material
  name                String
  colorName           String                     @default("N/A")
  standardColor       String?
  colorHex            String?
  costPerUnit         Float?
  partyId             String?
  isActive            Boolean                    @default(true)

  // Material hierarchy fields
  materialId          String?                    // Link to Material model
  constructionType    String?                    // "knit", "woven"
  pattern             String?                    // "single_jersey", "french_terry", "twill", "plain"
  weight              Float?                     // 180 (for gsm), 40 (for lea)
  weightUnit          String?                    // "gsm", "lea", "oz"
  composition         String?                    // "100% Cotton", "55% Linen 45% Cotton"
  avgShrinkagePct     Float?                     // Shrinkage percentage
  defaultLeadTimeDays Int?                       // Default lead time for colours
  defaultMinOrderQty  Float?                     // Default min order for colours
  unit                String?                    // "m", "kg"

  party               Party?                     @relation(fields: [partyId], references: [id])
  material            Material?                  @relation("MaterialFabrics", fields: [materialId], references: [id])
  fabricOrders        FabricOrder[]
  reconciliationItems FabricReconciliationItem[]
  colours             FabricColour[]             @relation("FabricColours")

  @@unique([materialId, name]) // Prevent duplicate fabric names under the same material
  @@index([partyId])
  @@index([materialId])
  @@index([constructionType])
  @@index([pattern])
}

/// Reusable accounting recipe — multiple parties share the same TransactionType
model TransactionType {
  id                   String   @id @default(uuid())
  name                 String   @unique  // "Fabric Purchase", "Service Payment"
  description          String?
  debitAccountCode     String?  // What to debit for outgoing (FABRIC_INVENTORY, etc.)
  creditAccountCode    String?  // What to credit for incoming (SALES_REVENUE, etc.)
  defaultGstRate       Float?   // Default GST % (18, 5, 0)
  defaultTdsApplicable Boolean  @default(false)
  defaultTdsSection    String?  // 194C, 194J, 194I, 194H
  defaultTdsRate       Float?   // Default TDS %
  invoiceRequired      Boolean  @default(true)
  expenseCategory      String?  // P&L category (fabric, service, rent, etc.)
  isActive             Boolean  @default(true)
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  parties    Party[]
  changeLogs TransactionTypeChangeLog[]
}

model Party {
  id                String   @id @default(uuid())
  name              String   @unique
  category          String   // fabric, trims, service, rent, marketing, logistics, packaging, statutory, other
  contactName       String?
  email             String?
  phone             String?
  address           String?
  gstin             String?
  pan               String?
  stateCode         String?
  tdsApplicable     Boolean  @default(false)
  tdsSection        String?
  tdsRate           Float?
  bankAccountName   String?
  bankAccountNumber String?
  bankIfsc          String?
  bankName          String?
  razorpayContactId String?
  paymentTermsDays        Int?
  billingPeriodOffsetMonths Int?    // e.g. -1 = billing period is one month before IST-derived month (Facebook/Google)
  aliases                 String[] @default([])
  invoiceRequired         Boolean  @default(true)
  isActive          Boolean  @default(true)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  transactionTypeId  String?
  transactionType    TransactionType? @relation(fields: [transactionTypeId], references: [id])

  fabrics                    Fabric[]
  fabricOrders               FabricOrder[]
  fabricColourTransactions   FabricColourTransaction[] @relation("FabricColourTxnParty")
  fabricColours              FabricColour[]      @relation("FabricColourParty")
  trimItems                  TrimItem[]          @relation("TrimParty")
  serviceItems               ServiceItem[]
  financeInvoices            Invoice[]           @relation("InvoiceParty")
  financePayments            Payment[]           @relation("PaymentParty")
  employee                   Employee?
  bankTransactions           BankTransaction[]   @relation("BankTxnParty")
  changeLogs                 PartyChangeLog[]

  @@index([category])
  @@index([transactionTypeId])
}

model TransactionTypeChangeLog {
  id                String          @id @default(uuid())
  transactionTypeId String
  fieldName         String
  oldValue          String?
  newValue          String?
  changedById       String
  createdAt         DateTime        @default(now())

  transactionType TransactionType @relation(fields: [transactionTypeId], references: [id], onDelete: Cascade)
  changedBy       User            @relation("TxnTypeChangeUser", fields: [changedById], references: [id])

  @@index([transactionTypeId])
  @@index([changedById])
  @@index([createdAt])
}

model PartyChangeLog {
  id          String   @id @default(uuid())
  partyId     String
  fieldName   String
  oldValue    String?
  newValue    String?
  changedById String
  createdAt   DateTime @default(now())

  party     Party @relation(fields: [partyId], references: [id], onDelete: Cascade)
  changedBy User  @relation("PartyChangeUser", fields: [changedById], references: [id])

  @@index([partyId])
  @@index([changedById])
}

// NOTE: FabricTransaction model removed - use FabricColourTransaction instead

model FabricOrder {
  id           String    @id @default(uuid())
  fabricId     String
  partyId      String
  qtyOrdered   Float
  unit         String
  costPerUnit  Float
  totalCost    Float
  orderDate    DateTime  @default(now())
  expectedDate DateTime?
  receivedDate DateTime?
  qtyReceived  Float?
  status       String    @default("ordered")
  notes        String?
  fabric       Fabric    @relation(fields: [fabricId], references: [id])
  party        Party     @relation(fields: [partyId], references: [id])

  @@index([fabricId])
  @@index([partyId])
  @@index([status])
}

model InventoryTransaction {
  id                String   @id @default(uuid())
  skuId             String
  txnType           String
  qty               Int
  reason            String
  referenceId       String?
  notes             String?
  warehouseLocation String?
  source            String?
  destination       String?
  tailorNumber      String?
  performedBy       String?
  repackingBarcode  String?
  userNotes         String?
  orderNotes        String?
  cohNotes          String?
  orderNumber       String?
  createdById       String
  createdAt         DateTime @default(now())
  createdBy         User     @relation(fields: [createdById], references: [id])
  sku               Sku      @relation(fields: [skuId], references: [id])

  @@index([skuId])
  @@index([txnType])
  @@index([createdAt])
  @@index([skuId, reason, createdAt])
  @@index([skuId, txnType])
  @@index([referenceId])
  @@index([orderNumber])
  @@index([createdById])          // FK — audit: who created this transaction
}

model Customer {
  id                String          @id @default(uuid())
  shopifyCustomerId String?         @unique
  email             String          @unique
  phone             String?
  firstName         String?
  lastName          String?
  defaultAddress    String?
  tags              String?
  acceptsMarketing  Boolean         @default(false)
  firstOrderDate    DateTime?
  lastOrderDate     DateTime?
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt
  exchangeCount     Int             @default(0)
  returnCount       Int             @default(0)
  rtoCount          Int             @default(0)  // Total lines RTO'd
  rtoOrderCount     Int             @default(0)  // Number of orders with at least one RTO
  rtoValue          Decimal         @default(0)  @db.Decimal(12, 2) // Total value of RTO'd items
  orderCount        Int             @default(0)  // Denormalized count of non-cancelled orders (for fast stats lookup)
  tier              String          @default("bronze")
  ltv               Int             @default(0)  // Stored LTV, updated incrementally on order changes
  storeCreditBalance Decimal        @default(0)  @db.Decimal(12, 2) // Store credit from return refunds
  bankAccountName   String?        // For return refund bank transfers
  bankAccountNumber String?
  bankIfsc          String?
  emailOptOut       Boolean         @default(false) // Unsubscribe from marketing emails
  feedback          Feedback[]
  orders            Order[]
  financeInvoices   Invoice[] @relation("InvoiceCustomer")
  financePayments   Payment[] @relation("PaymentCustomer")
  campaignRecipients EmailCampaignRecipient[]

  @@index([createdAt])
  @@index([tier])                 // Customer segmentation queries
  @@index([phone])                // Customer lookup by phone (support)
  @@index([lastOrderDate])        // Retention/churn analysis
}

model Order {
  id                   String             @id @default(uuid())
  orderNumber          String             @unique
  shopifyOrderId       String?            @unique
  channel              String             @default("shopify")
  customerId           String?
  customerName         String
  customerEmail        String?
  customerPhone        String?
  shippingAddress      String?
  orderDate            DateTime           @default(now())
  internalNotes        String?
  paymentMethod        String?
  status               String             @default("open")
  isArchived           Boolean            @default(false)
  archivedAt           DateTime?
  releasedToShipped    Boolean            @default(false)
  releasedToCancelled  Boolean            @default(false)
  totalAmount          Float
  createdAt            DateTime           @default(now())
  syncedAt             DateTime?
  codRemittanceUtr     String?
  codRemittedAmount    Float?
  codRemittedAt        DateTime?
  codShopifySyncError  String?
  codShopifySyncStatus String?
  codShopifySyncedAt   DateTime?
  // Generic settlement (works for both COD and Prepaid)
  settledAt            DateTime?          // When settlement confirmed (COD: remittance date, Prepaid: import time)
  settlementAmount     Float?             // Amount settled
  settlementRef        String?            // Reference (UTR, PayU settlementId, etc.)
  paymentGateway       String?            // Gateway name from Shopify (e.g., "Credit Card/Debit Card/NetBanking/UPI")
  isExchange           Boolean            @default(false)
  originalOrderId      String?
  shipByDate           DateTime?
  sheetPushedAt        DateTime?          // When order was pushed to "Orders from COH" sheet
  customerState        String?            // Customer's state for GST type determination (from shipping address)
  partiallyCancelled   Boolean            @default(false)
  paymentConfirmedAt   DateTime?
  paymentConfirmedBy   String?
  paymentStatus        String?            @default("pending")
  channelOrderId       String?            // BT Order Id for channel imports (e.g., "16557031119098")
  // UTM attribution fields (extracted from Shopify note_attributes)
  utmSource            String?
  utmMedium            String?
  utmCampaign          String?
  utmTerm              String?
  utmContent           String?
  fbclid               String?
  gclid                String?
  landingPage          String?
  customer             Customer?          @relation(fields: [customerId], references: [id])
  shopifyCache         ShopifyOrderCache? @relation(fields: [shopifyOrderId], references: [id])
  orderLines           OrderLine[]
  payments             OrderPayment[]     // Payment transactions for this order
  originalOrder        Order?             @relation("ExchangeOriginalOrder", fields: [originalOrderId], references: [id])
  exchangeOrders       Order[]            @relation("ExchangeOriginalOrder")
  exchangeSourceLines  OrderLine[]        @relation("ExchangeOrderLine") // Lines that created this exchange order
  returnPrimeRequests  ReturnPrimeRequest[] // Return Prime requests linked to this order
  channelOrderLines    ChannelOrderLine[] // BT report analytics lines linked to this order
  financeInvoices      Invoice[]           @relation("InvoiceOrder")

  @@index([customerId])
  @@index([status])
  @@index([orderDate])
  @@index([isArchived])
  @@index([isExchange])
  @@index([originalOrderId])
  @@index([shipByDate])
  @@index([paymentStatus])
  @@index([paymentMethod, paymentStatus])
  @@index([status, orderDate])
  @@index([customerId, orderDate])
  @@index([status, isArchived])
  @@index([status, isArchived, orderDate])
  @@index([isArchived, releasedToShipped])
  @@index([isArchived, releasedToCancelled])
  @@index([isArchived, releasedToShipped, orderDate])
  @@index([customerId, paymentStatus])
  @@index([paymentMethod, codRemittedAt])
  @@index([paymentMethod, settledAt])
  @@index([channelOrderId])
}

// ============================================
// ORDER PAYMENTS
// ============================================

model OrderPayment {
  id             String   @id @default(uuid())
  orderId        String
  amount         Float    // Payment amount in ₹
  paymentMethod  String?  // cash, bank_transfer, upi, card, cheque, etc.
  reference      String?  // Transaction ID, UTR, receipt number, cheque number
  notes          String?  // Additional notes about this payment
  recordedById   String   // User who recorded this payment
  recordedAt     DateTime @default(now())
  createdAt      DateTime @default(now())

  order      Order @relation(fields: [orderId], references: [id], onDelete: Cascade)
  recordedBy User  @relation(fields: [recordedById], references: [id])

  @@index([orderId])
  @@index([recordedAt])
  @@index([orderId, recordedAt]) // Compound: payment history for order
  @@index([recordedById])        // FK index for user lookups
}

model OrderLine {
  id                   String              @id @default(uuid())
  orderId              String
  shopifyLineId        String?
  skuId                String
  qty                  Int
  unitPrice            Float
  lineStatus           String              @default("pending")
  allocatedAt          DateTime?
  pickedAt             DateTime?
  packedAt             DateTime?
  shippedAt            DateTime?
  deliveredAt          DateTime?
  inventoryTxnId       String?
  productionBatchId    String?
  notes                String?
  // Tracking fields (single source of truth for each line)
  awbNumber            String?
  courier              String?
  trackingStatus       String?
  lastTrackingUpdate   DateTime?
  lastScanAt           DateTime?
  lastScanLocation     String?
  lastScanStatus       String?
  courierStatusCode    String?
  deliveryAttempts     Int?
  expectedDeliveryDate DateTime?
  // RTO fields
  rtoInitiatedAt       DateTime?
  rtoReceivedAt        DateTime?
  rtoCondition         String?
  rtoInwardedAt        DateTime?
  rtoInwardedById      String?
  rtoNotes             String?
  // Customization
  customizedAt         DateTime?
  customizedById       String?
  isCustomized         Boolean             @default(false)
  isNonReturnable      Boolean             @default(false)
  originalSkuId        String?
  // Refund
  refundAmount         Float?
  refundNotes          String?
  refundReason         String?
  refundedAt           DateTime?
  // Custom shipping address (for multi-destination orders)
  shippingAddress      String?
  // Channel import fields
  channelFulfillmentStatus  String?    // Raw CSV status: processing, shipped, delivered, manifested, packed, cancelled
  channelItemId             String?    // BT Item ID for line-level matching on re-upload

  // === RETURN LIFECYCLE ===
  returnBatchNumber         String?       // Groups lines returned together, e.g., "64168/1", "64168/2"
  returnStatus              String?       // 'requested', 'pickup_scheduled', 'in_transit', 'received', 'complete', 'cancelled'
  returnQty                 Int?          // qty being returned (supports partial returns)
  returnRequestedAt         DateTime?
  returnRequestedById       String?

  // === PICKUP/LOGISTICS ===
  returnPickupType          String?       // 'arranged_by_us', 'customer_shipped'
  returnAwbNumber           String?
  returnCourier             String?
  returnPickupScheduledAt   DateTime?
  returnPickupAt            DateTime?
  returnReceivedAt          DateTime?
  returnReceivedById        String?

  // === CONDITION & QC ===
  returnCondition           String?       // 'good', 'damaged', 'defective', 'wrong_item', 'used'
  returnConditionNotes      String?
  returnQcResult            String?       // 'approved', 'written_off' — set by repacking QC cascade

  // === REASON ===
  returnReasonCategory      String?       // 'fit_size', 'product_quality', 'product_different', 'wrong_item_sent', 'damaged_in_transit', 'changed_mind', 'other'
  returnReasonDetail        String?

  // === RESOLUTION ===
  returnResolution          String?       // 'refund', 'exchange', 'rejected'

  // === REFUND CALCULATION ===
  returnGrossAmount         Decimal?      @db.Decimal(10, 2)
  returnDiscountClawback    Decimal?      @db.Decimal(10, 2)
  returnDeductions          Decimal?      @db.Decimal(10, 2)
  returnDeductionNotes      String?
  returnNetAmount           Decimal?      @db.Decimal(10, 2)

  // === REFUND EXECUTION (enhances existing refund fields) ===
  returnRefundRequestedMode String?       // Customer's preferred refund mode from RP (e.g., 'Original Payment Method', 'Store Credit')
  returnRefundLinkSentAt    DateTime?
  returnRefundLinkId        String?
  returnRefundLinkUrl       String?       // RazorpayX payout link short URL
  returnRefundCompletedAt   DateTime?
  returnRefundMethod        String?       // 'payment_link', 'bank_transfer', 'store_credit'
  returnRefundReference     String?
  returnShippingFee         Decimal?      @db.Decimal(10, 2) // RP return fee per line

  // === EXCHANGE ===
  returnExchangeOrderId     String?       // FK to the exchange Order
  returnExchangeSkuId       String?       // what they're exchanging to
  returnExchangePriceDiff   Decimal?      @db.Decimal(10, 2)

  // === MANUAL CLOSE (edge cases) ===
  returnClosedManually      Boolean?
  returnClosedManuallyAt    DateTime?
  returnClosedManuallyById  String?
  returnClosedReason        String?

  // === INTERNAL ===
  returnNotes               String?

  // === RETURN PRIME INTEGRATION ===
  returnPrimeRequestId        String?    // RP request ID
  returnPrimeRequestNumber    String?    // Human-readable (e.g., "RET625")
  returnPrimeStatus           String?    // approved, received, inspected, refunded, rejected, archived
  returnPrimeCreatedAt        DateTime?
  returnPrimeUpdatedAt        DateTime?
  returnPrimeSyncedAt         DateTime?  // Last sync TO Return Prime
  returnPrimeSyncError        String?    // For retry logic
  returnPrimeExchangeShopifyOrderId String? // Shopify order ID of RP-created exchange order

  // Relations
  customizedBy         User?               @relation("CustomizedBy", fields: [customizedById], references: [id])
  order                Order               @relation(fields: [orderId], references: [id])
  productionBatch      ProductionBatch?    @relation(fields: [productionBatchId], references: [id])
  rtoInwardedBy        User?               @relation("RtoInwardedBy", fields: [rtoInwardedById], references: [id])
  sku                  Sku                 @relation(fields: [skuId], references: [id])
  repackingQueueItems  RepackingQueueItem[] @relation("OrderLineToRepacking")
  returnRequestedBy    User?               @relation("ReturnRequestedBy", fields: [returnRequestedById], references: [id])
  returnReceivedBy     User?               @relation("ReturnReceivedBy", fields: [returnReceivedById], references: [id])
  returnClosedManuallyBy User?             @relation("ReturnClosedManuallyBy", fields: [returnClosedManuallyById], references: [id])
  returnExchangeOrder  Order?              @relation("ExchangeOrderLine", fields: [returnExchangeOrderId], references: [id])
  channelOrderLines    ChannelOrderLine[] // BT report analytics lines linked to this order line
  invoiceLines         InvoiceLine[]       @relation("InvoiceLineOrderLine")

  @@index([orderId])
  @@index([skuId])
  @@index([lineStatus])
  @@index([productionBatchId])
  @@index([lineStatus, orderId])
  @@index([rtoInwardedById])
  @@index([customizedById])
  @@index([awbNumber])
  @@index([skuId, rtoCondition])
  @@index([orderId, rtoCondition])
  @@index([lineStatus, skuId])
  @@index([skuId, lineStatus])
  @@index([orderId, lineStatus, shippedAt])
  @@index([awbNumber, courier])
  @@index([lineStatus, allocatedAt])
  @@index([trackingStatus])
  @@index([orderId, trackingStatus])
  // Return indexes
  @@index([returnBatchNumber])
  @@index([returnStatus])
  @@index([returnStatus, orderId])
  @@index([returnAwbNumber])
  @@index([returnRequestedAt])
  @@index([returnRequestedById])
  @@index([returnReceivedById])
  @@index([returnClosedManuallyById])
  @@index([returnExchangeOrderId])
  @@index([returnPrimeRequestId])
  @@index([returnPrimeStatus, returnPrimeUpdatedAt])  // Composite for status queries
}

model Feedback {
  id           String                @id @default(uuid())
  customerId   String?
  orderId      String?
  orderLineId  String?
  source       String
  feedbackType String
  status       String                @default("new")
  createdAt    DateTime              @default(now())
  updatedAt    DateTime              @updatedAt
  customer     Customer?             @relation(fields: [customerId], references: [id])
  content      FeedbackContent?
  media        FeedbackMedia[]
  productLinks FeedbackProductLink[]
  ratings      FeedbackRating[]
  tags         FeedbackTag[]

  @@index([customerId])
  @@index([status])
}

model FeedbackRating {
  id         String   @id @default(uuid())
  feedbackId String
  dimension  String
  score      Int
  feedback   Feedback @relation(fields: [feedbackId], references: [id])

  @@index([feedbackId]) // FK index
}

model FeedbackContent {
  id             String   @id @default(uuid())
  feedbackId     String   @unique
  title          String?
  body           String?
  pros           String?
  cons           String?
  wouldRecommend Boolean?
  feedback       Feedback @relation(fields: [feedbackId], references: [id])
}

model FeedbackMedia {
  id         String   @id @default(uuid())
  feedbackId String
  mediaType  String
  url        String
  caption    String?
  feedback   Feedback @relation(fields: [feedbackId], references: [id])

  @@index([feedbackId]) // FK index
}

model FeedbackProductLink {
  id          String   @id @default(uuid())
  feedbackId  String
  productId   String?
  variationId String?
  skuId       String?
  feedback    Feedback @relation(fields: [feedbackId], references: [id])
  sku         Sku?     @relation(fields: [skuId], references: [id])

  @@index([feedbackId])  // FK index
  @@index([productId])   // FK index for product lookup
  @@index([variationId]) // FK index for variation lookup
}

model FeedbackTag {
  id         String   @id @default(uuid())
  feedbackId String
  tag        String
  feedback   Feedback @relation(fields: [feedbackId], references: [id])

  @@index([feedbackId]) // FK index
}

model Tailor {
  id                String            @id @default(uuid())
  name              String            @unique // Prevent duplicate tailor names
  specializations   String?
  dailyCapacityMins Int               @default(480)
  isActive          Boolean           @default(true)
  createdAt         DateTime          @default(now())
  productionBatches ProductionBatch[]
  employee          Employee?
}

model ProductionBatch {
  id                String      @id @default(uuid())
  batchCode         String?     @unique
  batchDate         DateTime    @default(now())
  tailorId          String?
  skuId             String?     // Nullable for sample batches
  sampleCode        String?     @unique  // SAMPLE-01, SAMPLE-02, etc.
  sampleName        String?     // Description of sample item
  sampleColour      String?     // Colour for sample item
  sampleSize        String?     // Size for sample item
  qtyPlanned        Int
  qtyCompleted      Int         @default(0)
  priority          String
  sourceOrderLineId String?
  status            String      @default("planned")
  notes             String?
  createdAt         DateTime    @default(now())
  completedAt       DateTime?
  orderLines        OrderLine[]
  sku               Sku?        @relation(fields: [skuId], references: [id])  // Optional for samples
  tailor            Tailor?     @relation(fields: [tailorId], references: [id])

  @@index([skuId])
  @@index([tailorId])
  @@index([batchDate])
  @@index([status])
  @@index([batchDate, batchCode])
  @@index([skuId, status])
}

model RepackingQueueItem {
  id              String         @id @default(uuid())
  skuId           String
  qty             Int            @default(1)
  status          String         @default("pending")
  condition       String
  inspectionNotes String?
  writeOffReason  String?
  createdAt       DateTime       @default(now())
  processedAt     DateTime?
  processedById   String?
  qcComments      String?
  orderLineId     String?
  processedBy     User?          @relation("RepackingProcessor", fields: [processedById], references: [id])
  orderLine       OrderLine?     @relation("OrderLineToRepacking", fields: [orderLineId], references: [id])
  sku             Sku            @relation(fields: [skuId], references: [id])

  @@index([skuId])
  @@index([status])
  @@index([orderLineId])
  @@index([skuId, status])
}

model WriteOffLog {
  id          String   @id @default(uuid())
  skuId       String
  qty         Int
  reason      String
  sourceType  String
  sourceId    String?
  notes       String?
  costValue   Float?
  createdById String
  createdAt   DateTime @default(now())
  createdBy   User     @relation("WriteOffCreator", fields: [createdById], references: [id])
  sku         Sku      @relation(fields: [skuId], references: [id])

  @@index([skuId])
  @@index([reason])
  @@index([createdAt])
}

model ShopifyInventoryCache {
  skuId                  String   @id
  shopifyInventoryItemId String
  availableQty           Int
  lastSynced             DateTime @default(now())
  sku                    Sku      @relation(fields: [skuId], references: [id])
}

model ShopifyProductCache {
  id              String    @id
  rawData         String
  title           String?
  handle          String?
  lastWebhookAt   DateTime  @default(now())
  webhookTopic    String?
  processedAt     DateTime?
  processingError String?
  createdAt       DateTime  @default(now())

  @@index([handle])
  @@index([processedAt])
  @@index([lastWebhookAt])
}

model SystemSetting {
  key       String   @id
  value     String
  updatedAt DateTime @updatedAt
}

/// Return policy settings (singleton - only one row)
model ReturnSettings {
  id                    String   @id @default("default")
  /// Days from delivery within which returns are accepted
  windowDays            Int      @default(14)
  /// Days before window expiry to show warning (e.g., 12 means 2 days left warning)
  windowWarningDays     Int      @default(12)
  /// Auto-reject returns after this many days (null = allow with override)
  autoRejectAfterDays   Int?
  /// Allow returns after window expires with manual override
  allowExpiredOverride  Boolean  @default(true)
  /// Return shipping fee (flat amount in INR, deducted from refund)
  returnShippingFee     Decimal? @db.Decimal(10, 2)
  /// Restocking fee type: 'flat' or 'percent'
  restockingFeeType     String?
  /// Restocking fee value (flat INR amount or percentage 0-100)
  restockingFeeValue    Decimal? @db.Decimal(10, 2)
  updatedAt             DateTime @updatedAt
  updatedById           String?
  updatedBy             User?    @relation(fields: [updatedById], references: [id])
}

model SyncJob {
  id              String    @id @default(uuid())
  jobType         String
  status          String    @default("pending")
  dateFilter      String?
  daysBack        Int?
  syncMode        String?
  staleAfterMins  Int?
  totalRecords    Int?
  processed       Int       @default(0)
  created         Int       @default(0)
  updated         Int       @default(0)
  skipped         Int       @default(0)
  errors          Int       @default(0)
  lastProcessedId String?
  currentBatch    Int       @default(0)
  errorLog        String?
  lastError       String?
  startedAt       DateTime?
  completedAt     DateTime?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  @@index([status])
  @@index([jobType])
  @@index([createdAt])
}

model ShopifyOrderCache {
  id                    String    @id
  rawData               String
  orderNumber           String?
  financialStatus       String?
  fulfillmentStatus     String?
  lastWebhookAt         DateTime  @default(now())
  webhookTopic          String?
  processedAt           DateTime?
  processingError       String?
  createdAt             DateTime  @default(now())
  customerNotes         String?
  discountCodes         String?
  paymentMethod         String?
  shippedAt             DateTime?
  shippingCity          String?
  shippingCountry       String?
  shippingState         String?
  tags                  String?
  trackingCompany       String?
  trackingNumber        String?
  trackingUrl           String?
  deliveredAt           DateTime?
  fulfillmentUpdatedAt  DateTime?
  shipmentStatus        String?
  processingLock        DateTime?
  billingCity           String?
  billingName           String?
  billingPhone          String?
  billingState          String?
  billingZip            String?
  buyerAcceptsMarketing Boolean?
  cancelReason          String?
  confirmationNumber    String?
  currency              String?
  customerEmail         String?
  customerFirstName     String?
  customerId            String?
  customerLastName      String?
  customerPhone         String?
  fulfillmentCount      Int?
  isConfirmed           Boolean?
  isTaxExempt           Boolean?
  isTest                Boolean?
  lineItemCount         Int?
  paymentGatewayNames   String?
  refundCount           Int?
  shippingAddress1      String?
  shippingAddress2      String?
  shippingCountryCode   String?
  shippingLatitude      Float?
  shippingLongitude     Float?
  shippingName          String?
  shippingPhone         String?
  shippingProvince      String?
  shippingProvinceCode  String?
  shippingZip           String?
  shopifyCancelledAt    DateTime?
  shopifyClosedAt       DateTime?
  shopifyCreatedAt      DateTime?
  shopifyOrderName      String?
  shopifyProcessedAt    DateTime?
  shopifyUpdatedAt      DateTime?
  sourceName            String?
  totalLineItemsPrice   Float?
  totalOutstanding      Float?
  totalShippingPrice    Float?
  totalPrice            Decimal?  @db.Decimal
  subtotalPrice         Decimal?  @db.Decimal
  totalTax              Decimal?  @db.Decimal
  totalDiscounts        Decimal?  @db.Decimal

  // Line item and order details (eliminates rawData parsing)
  lineItemsJson         String?   // [{id, sku, title, variant_title, price, quantity, discount_allocations}]
  shippingLinesJson     String?   // [{title, price}]
  taxLinesJson          String?   // [{title, price, rate}]
  noteAttributesJson    String?   // [{name, value}]

  // Missing billing address fields
  billingAddress1       String?
  billingAddress2       String?
  billingCountry        String?
  billingCountryCode    String?

  order                 Order?

  @@index([orderNumber])
  @@index([processedAt])
  @@index([lastWebhookAt])
}

model WebhookLog {
  id             String    @id @default(uuid())
  webhookId      String    @unique
  topic          String
  resourceId     String?
  source         String    @default("shopify")  // 'shopify' | 'returnprime'
  status         String    @default("received")
  responseCode   Int?
  processingTime Int?
  error          String?
  payload        String?   // Raw webhook JSON payload (truncated for large payloads)
  resultData     String?   // JSON of DB changes: {action, orderId, orderNumber, linesCreated, etc.}
  receivedAt     DateTime  @default(now())
  processedAt    DateTime?

  @@index([webhookId])
  @@index([topic])
  @@index([resourceId])
  @@index([receivedAt])
  @@index([source, topic])
}

// Stores raw iThink API responses for debugging (max 5 per AWB, rotated)
model TrackingApiResponse {
  id         String   @id @default(uuid())
  awbNumber  String
  source     String   // 'sync' | 'manual' | 'webhook'
  statusCode Int      // HTTP-like status (200 for success, 404 for not found, etc.)
  response   Json     // Full raw response from iThink API
  createdAt  DateTime @default(now())

  @@index([awbNumber])
  @@index([awbNumber, createdAt])
}

model FailedSyncItem {
  id          String    @id @default(uuid())
  itemType    String
  resourceId  String
  rawData     String?
  error       String
  retryCount  Int       @default(0)
  maxRetries  Int       @default(5)
  nextRetryAt DateTime?
  status      String    @default("pending")
  resolvedAt  DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@unique([itemType, resourceId])
  @@index([status])
  @@index([nextRetryAt])
  @@index([itemType])
}

model FabricReconciliation {
  id            String                     @id @default(uuid())
  reconcileDate DateTime                   @default(now())
  status        String                     @default("draft")
  notes         String?
  createdBy     String?
  createdAt     DateTime                   @default(now())
  updatedAt     DateTime                   @updatedAt
  items         FabricReconciliationItem[]

  @@index([status])
  @@index([createdAt])
}

model FabricReconciliationItem {
  id               String               @id @default(uuid())
  reconciliationId String
  fabricId         String
  systemQty        Float
  physicalQty      Float?
  variance         Float?
  adjustmentReason String?
  notes            String?
  txnId            String?              @unique
  fabric           Fabric               @relation(fields: [fabricId], references: [id])
  reconciliation   FabricReconciliation @relation(fields: [reconciliationId], references: [id], onDelete: Cascade)

  @@index([reconciliationId])
  @@index([fabricId])
}

model InventoryReconciliation {
  id            String                        @id @default(uuid())
  reconcileDate DateTime                      @default(now())
  status        String                        @default("draft")
  notes         String?
  createdBy     String?
  createdAt     DateTime                      @default(now())
  updatedAt     DateTime                      @updatedAt
  items         InventoryReconciliationItem[]

  @@index([status])
  @@index([createdAt])
}

model InventoryReconciliationItem {
  id               String                  @id @default(uuid())
  reconciliationId String
  skuId            String
  systemQty        Int
  physicalQty      Int?
  variance         Int?
  adjustmentReason String?
  notes            String?
  txnId            String?                 @unique
  reconciliation   InventoryReconciliation @relation(fields: [reconciliationId], references: [id], onDelete: Cascade)
  sku              Sku                     @relation(fields: [skuId], references: [id])

  @@index([reconciliationId])
  @@index([skuId])
}

model Pincode {
  id        String   @id @default(uuid())
  pincode   String   @unique
  district  String
  state     String
  region    String?
  division  String?
  createdAt DateTime @default(now())

  @@index([state])
  @@index([district])
}

// ============================================
// CATALOG MODELS (TrimItem, ServiceItem)
// ============================================

model TrimItem {
  id            String   @id @default(uuid())
  code          String   @unique // "BTN-SHELL-18L"
  name          String            // "Shell Button 18L"
  category      String            // "button", "zipper", "elastic", "label", "thread"
  description   String?

  costPerUnit   Float
  unit          String   @default("piece") // "piece", "meter", "spool"

  partyId       String?
  minOrderQty   Float?
  leadTimeDays  Int?

  isActive      Boolean  @default(true)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  party         Party?   @relation("TrimParty", fields: [partyId], references: [id])

  // BOM usages
  productBomTemplates ProductBomTemplate[]
  variationBomLines   VariationBomLine[]
  skuBomLines         SkuBomLine[]

  @@index([category])
  @@index([partyId])
}

model ServiceItem {
  id           String   @id @default(uuid())
  code         String   @unique // "PRINT-BLOCK-INDIGO"
  name         String            // "Block Print - Indigo Floral"
  category     String            // "printing", "embroidery", "washing", "dyeing"
  description  String?

  costPerJob   Float             // Base cost per unit processed
  costUnit     String   @default("per_piece") // "per_piece", "per_meter"

  partyId      String?
  leadTimeDays Int?

  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  party        Party?   @relation(fields: [partyId], references: [id])

  // BOM usages
  productBomTemplates ProductBomTemplate[]
  variationBomLines   VariationBomLine[]
  skuBomLines         SkuBomLine[]

  @@index([category])
  @@index([partyId])
}

// ============================================
// BOM COMPONENT TYPE DEFINITIONS
// ============================================

model ComponentType {
  id             String          @id @default(uuid())
  code           String          @unique // "FABRIC", "TRIM", "SERVICE"
  name           String                   // "Fabric", "Trim", "Service"
  trackInventory Boolean         @default(true) // false for SERVICE
  sortOrder      Int             @default(0)
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt

  roles          ComponentRole[]
}

model ComponentRole {
  id              String        @id @default(uuid())
  typeId          String
  code            String        // "main", "accent", "lining", "button", "print"
  name            String        // "Main Fabric", "Button", "Block Print"
  isRequired      Boolean       @default(false) // true for "main"
  allowMultiple   Boolean       @default(false) // true for some trims
  defaultQuantity Float?        // e.g., 7 for buttons
  defaultUnit     String?       // "meter", "piece", "job"
  sortOrder       Int           @default(0)
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  type            ComponentType @relation(fields: [typeId], references: [id])

  // BOM usages
  productBomTemplates ProductBomTemplate[]
  variationBomLines   VariationBomLine[]
  skuBomLines         SkuBomLine[]

  @@unique([typeId, code])
  @@index([typeId])
}

// ============================================
// 3-LEVEL BOM SYSTEM
// ============================================

// Level 1: Product BOM Template (structure + defaults)
model ProductBomTemplate {
  id              String   @id @default(uuid())
  productId       String
  roleId          String   // ComponentRole.id

  // Component (optional at product level - fabric colors set at variation)
  trimItemId      String?  // Trims CAN be set here (same buttons for all colors)
  serviceItemId   String?  // Services CAN be set here (same print for all colors)
  // Note: fabricColourId NOT here - fabrics are color-specific, set at variation

  // Default quantity (inherited by variations and SKUs)
  defaultQuantity Float    @default(1)
  quantityUnit    String   @default("unit") // "meter", "piece", "job"
  wastagePercent  Float    @default(0)
  notes           String?

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  product         Product       @relation(fields: [productId], references: [id], onDelete: Cascade)
  role            ComponentRole @relation(fields: [roleId], references: [id])
  trimItem        TrimItem?     @relation(fields: [trimItemId], references: [id])
  serviceItem     ServiceItem?  @relation(fields: [serviceItemId], references: [id])

  @@unique([productId, roleId]) // One template per role per product
  @@index([productId])
  @@index([roleId])
}

// Level 2: Variation BOM Override (fabric colors + overrides)
model VariationBomLine {
  id             String   @id @default(uuid())
  variationId    String
  roleId         String   // ComponentRole.id

  // Component overrides (null = inherit from product template)
  fabricColourId String?  // REQUIRED for fabric roles (color-specific)
  trimItemId     String?  // Override trim if this variant uses different one
  serviceItemId  String?  // Override service if this variant uses different one

  // Quantity override (null = inherit from product template)
  quantity       Float?
  wastagePercent Float?
  notes          String?

  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  variation      Variation     @relation(fields: [variationId], references: [id], onDelete: Cascade)
  role           ComponentRole @relation(fields: [roleId], references: [id])
  fabricColour   FabricColour? @relation(fields: [fabricColourId], references: [id])
  trimItem       TrimItem?     @relation(fields: [trimItemId], references: [id])
  serviceItem    ServiceItem?  @relation(fields: [serviceItemId], references: [id])

  @@unique([variationId, roleId]) // One line per role per variation
  @@index([variationId])
  @@index([roleId])
  @@index([fabricColourId])
}

// Level 3: SKU BOM Line (size-specific overrides)
model SkuBomLine {
  id             String   @id @default(uuid())
  skuId          String
  roleId         String   // ComponentRole.id

  // Component override (null = inherit from variation → product)
  fabricColourId String?  // Rare: specific SKU uses different fabric
  trimItemId     String?
  serviceItemId  String?

  // Quantity override (null = inherit from variation → product)
  quantity       Float?   // Common: XL uses more fabric
  wastagePercent Float?
  overrideCost   Float?   // Override catalog cost if needed
  notes          String?

  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  sku            Sku           @relation(fields: [skuId], references: [id], onDelete: Cascade)
  role           ComponentRole @relation(fields: [roleId], references: [id])
  fabricColour   FabricColour? @relation(fields: [fabricColourId], references: [id])
  trimItem       TrimItem?     @relation(fields: [trimItemId], references: [id])
  serviceItem    ServiceItem?  @relation(fields: [serviceItemId], references: [id])

  @@unique([skuId, roleId]) // One line per role per SKU
  @@index([skuId])
  @@index([roleId])
}

// ============================================
// FABRIC COLOUR TRANSACTIONS (NEW - replaces FabricTransaction)
// ============================================

model FabricColourTransaction {
  id              String        @id @default(uuid())
  fabricColourId  String
  txnType         String        // "inward" | "outward"
  qty             Float
  unit            String
  reason          String
  costPerUnit     Float?
  partyId         String?
  referenceId     String?
  notes           String?
  receiptDate     DateTime?
  createdById     String
  createdAt       DateTime      @default(now())

  fabricColour    FabricColour  @relation(fields: [fabricColourId], references: [id])
  createdBy       User          @relation("FabricColourTxnCreator", fields: [createdById], references: [id])
  party           Party?        @relation("FabricColourTxnParty", fields: [partyId], references: [id])
  invoiceLine     InvoiceLine?   @relation("FinanceInvoiceLineTxn")

  @@index([fabricColourId])
  @@index([txnType])
  @@index([createdAt])
  @@index([fabricColourId, createdAt])
  @@index([fabricColourId, txnType]) // Optimizes balance aggregation queries
  @@index([partyId])
  @@index([createdById])
}

// ============================================
// FABRIC COLOUR RECONCILIATION (NEW - replaces FabricReconciliation)
// ============================================

model FabricColourReconciliation {
  id            String                            @id @default(uuid())
  reconcileDate DateTime                          @default(now())
  status        String                            @default("draft")
  notes         String?
  createdBy     String?
  createdAt     DateTime                          @default(now())
  updatedAt     DateTime                          @updatedAt
  items         FabricColourReconciliationItem[]

  @@index([status])
  @@index([createdAt])
}

model FabricColourReconciliationItem {
  id               String                      @id @default(uuid())
  reconciliationId String
  fabricColourId   String
  systemQty        Float
  physicalQty      Float?
  variance         Float?
  adjustmentReason String?
  notes            String?
  txnId            String?                     @unique
  fabricColour     FabricColour                @relation(fields: [fabricColourId], references: [id])
  reconciliation   FabricColourReconciliation  @relation(fields: [reconciliationId], references: [id], onDelete: Cascade)

  @@index([reconciliationId])
  @@index([fabricColourId])
}

// ============================================
// FABRIC STOCK COUNT (Warehouse physical count pool)
// ============================================

model FabricStockCount {
  id             String   @id @default(uuid())
  fabricColourId String
  physicalQty    Float
  countedById    String
  countedAt      DateTime @default(now())
  status         String   @default("pending")  // pending | applied | discarded
  notes          String?

  fabricColour   FabricColour @relation(fields: [fabricColourId], references: [id])
  countedBy      User         @relation("FabricStockCountCreator", fields: [countedById], references: [id])

  @@index([status])
  @@index([countedAt])
  @@index([fabricColourId])
}

// ============================================
// CHANNEL ORDER ANALYTICS (Marketplace Data)
// ============================================

/// Line-level data from BT reports for marketplace channels (Myntra, Ajio, Nykaa)
model ChannelOrderLine {
  id                  String    @id @default(uuid())

  // Channel & Order Identity
  channel             String                    // "myntra", "ajio", "nykaa"
  channelOrderId      String                    // BT Order Id (e.g., "16557031058666")
  channelRef          String?                   // Channel Ref UUID
  channelItemId       String                    // Item ID from BT

  // Order Info
  orderDate           DateTime
  orderType           String                    // "COD" or "Prepaid"
  financialStatus     String?                   // "Paid", "Cod"
  fulfillmentStatus   String?                   // "processing", "shipped", "delivered", "rto return pending", etc.

  // SKU Info
  skuCode             String                    // Maps to our SKU
  channelSkuCode      String?                   // Channel's SKU code
  skuTitle            String?
  quantity            Int                       @default(1)

  // Pricing (stored in paise for precision)
  mrp                 Int?                      // MRP in paise
  sellerPrice         Int?                      // Seller's Price
  buyerPrice          Int?                      // Buyer's Price (after discount)
  itemTotal           Int?                      // Item Total
  itemDiscount        Int?                      // Item Total Discount Value
  orderTotal          Int?                      // Order Total Amount

  // Tax
  taxPercent          Float?
  taxType             String?                   // "SGST/CGST" or "IGST"
  taxAmount           Int?                      // in paise

  // Shipping
  courierName         String?
  trackingNumber      String?

  // Dates
  dispatchByDate      DateTime?
  dispatchDate        DateTime?
  manifestedDate      DateTime?
  deliveryDate        DateTime?                 // Channel Delivery Date
  returnDate          DateTime?                 // BT Return Date
  channelReturnDate   DateTime?

  // Customer (denormalized for analytics)
  customerName        String?
  customerCity        String?
  customerState       String?
  customerZip         String?

  // Metadata
  invoiceNumber       String?
  batchNo             String?
  hsnCode             String?

  // ERP linkage
  orderId             String?                   // FK to ERP Order
  orderLineId         String?                   // FK to ERP OrderLine
  order               Order?    @relation(fields: [orderId], references: [id])
  orderLine           OrderLine? @relation(fields: [orderLineId], references: [id])

  // Import tracking
  importedAt          DateTime  @default(now())
  importBatchId       String?                   // Track which upload batch

  // Unique constraint: one line per channel + order + item
  @@unique([channel, channelOrderId, channelItemId])

  // Indexes for analytics queries
  @@index([channel])
  @@index([orderDate])
  @@index([channel, orderDate])
  @@index([fulfillmentStatus])
  @@index([skuCode])
  @@index([customerState])
  @@index([importBatchId])
  @@index([orderId])
  @@index([orderLineId])
}

/// Track import history for BT report uploads
model ChannelImportBatch {
  id            String    @id @default(uuid())
  channel       String                       // "myntra", "ajio", "nykaa", or "all"
  filename      String
  rowsTotal     Int
  rowsImported  Int
  rowsSkipped   Int
  rowsUpdated   Int
  errors        String?                       // JSON array of errors
  dateRangeStart DateTime?
  dateRangeEnd   DateTime?
  importedAt    DateTime  @default(now())
  importedBy    String?                       // User ID
  importType    String    @default("analytics")  // "analytics" | "order_import"
  ordersCreated Int       @default(0)
  ordersUpdated Int       @default(0)

  @@index([channel])
  @@index([importedAt])
}

// ============================================
// RETURN PRIME LOCAL CACHE
// ============================================

/// Stores Return Prime requests locally for faster dashboard loading and historical analytics
model ReturnPrimeRequest {
  id                    String    @id @default(uuid())

  // Return Prime identifiers
  rpRequestId           String    @unique  // Return Prime's request ID
  rpRequestNumber       String               // e.g., "RET9183" or "EXC9184"
  requestType           String               // "return" or "exchange"

  // Order reference
  shopifyOrderId        String?
  shopifyOrderName      String?              // e.g., "64377"
  orderId               String?              // COH-ERP Order ID if linked

  // Customer info
  customerName          String?
  customerEmail         String?
  customerPhone         String?
  customerAddress       Json?                // Full address object
  customerBank          Json?                // Bank details for refunds

  // Status flags with timestamps
  isApproved            Boolean   @default(false)
  approvedAt            DateTime?
  approvedComment       String?

  isReceived            Boolean   @default(false)
  receivedAt            DateTime?
  receivedComment       String?

  isInspected           Boolean   @default(false)
  inspectedAt           DateTime?
  inspectedComment      String?

  isRefunded            Boolean   @default(false)
  refundedAt            DateTime?

  isRejected            Boolean   @default(false)
  rejectedAt            DateTime?
  rejectedComment       String?

  isArchived            Boolean   @default(false)
  archivedAt            DateTime?

  // Line items stored as JSON array
  lineItems             Json      @default("[]")
  lineItemCount         Int       @default(0)

  // Computed values for fast queries
  totalValue            Decimal   @default(0) @db.Decimal(10, 2)
  primaryReason         String?              // First line item's reason

  // Return Prime timestamps
  rpCreatedAt           DateTime             // When created in Return Prime
  rpUpdatedAt           DateTime?            // Last update in Return Prime

  // Sync tracking
  syncedAt              DateTime  @default(now())
  rawData               Json?                // Full API response for reference

  // Timestamps
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  // Relations
  order                 Order?    @relation(fields: [orderId], references: [id])

  @@index([rpRequestNumber])
  @@index([shopifyOrderId])
  @@index([shopifyOrderName])
  @@index([requestType])
  @@index([rpCreatedAt])
  @@index([isApproved, isReceived, isRefunded])
  @@index([customerEmail])
  @@index([syncedAt])
  @@index([orderId])              // FK — return requests for an order
}

/// CSV-only enrichment for Return Prime requests (reason details, inspection notes, etc.)
/// Keyed by request number because CSV export does not include Return Prime request ID.
model ReturnPrimeCsvEnrichment {
  id                  String   @id @default(uuid())
  requestNumber       String   @unique   // serial_number, e.g. RET1234 / EXC1234
  requestType         String?
  status              String?
  csvReason           String?            // Raw CSV reason column (often "Others")
  customerComment     String?            // Detailed customer-provided reason text
  inspectionNotes     String?            // QC/inspection notes from CSV
  notes               String?            // Internal notes from CSV
  refundStatus        String?
  requestedRefundMode String?
  actualRefundMode    String?
  refundedAtRaw       String?            // Raw CSV date string
  pickupAwb           String?
  pickupLogistics     String?
  sourceFile          String?
  rawRow              Json?
  importedAt          DateTime @default(now())
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  @@index([requestType])
  @@index([status])
  @@index([importedAt])
}

model MonthlyStockSnapshot {
  id               String   @id @default(uuid())
  skuId            String
  month            DateTime // 1st of month in UTC (e.g. 2026-01-01T00:00:00Z)
  openingStock     Int
  totalInward      Int
  totalOutward     Int
  closingStock     Int      // = opening + inward - outward
  inwardBreakdown  Json     @default("{}")  // {"production": 50, "return_receipt": 5}
  outwardBreakdown Json     @default("{}")  // {"sale": 40, "damage": 1}
  computedAt       DateTime @default(now())
  sku              Sku      @relation(fields: [skuId], references: [id])

  @@unique([skuId, month])
  @@index([month])
  @@index([skuId])
}

// ============================================
// FABRIC INVOICES (AI-parsed supplier invoices)
// ============================================

// ============================================
// FINANCE: LEDGER, INVOICES, PAYMENTS
// ============================================

/// Chart of accounts — seeded from config, balances maintained by DB trigger
model LedgerAccount {
  id        String   @id @default(uuid())
  code      String   @unique
  name      String
  type      String   // asset, liability, income, direct_cost, expense, equity
  balance   Float    @default(0) // Maintained by DB trigger on LedgerEntryLine changes
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  lines LedgerEntryLine[]

  @@index([type])
}

/// A journal entry (header) — groups debit/credit lines that must balance
model LedgerEntry {
  id           String   @id @default(uuid())
  entryDate    DateTime
  period       String   // "YYYY-MM" — which P&L month this belongs to (accrual basis)
  description  String
  sourceType   String   // fabric_inward, production_inward, invoice_confirmed, manual, etc.
  sourceId     String?  // FK to originating record (for idempotency + tracing)
  isReversed   Boolean  @default(false)
  reversedById String?  // FK to the reversal entry
  notes        String?
  createdById  String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  createdBy  User          @relation("LedgerEntryCreator", fields: [createdById], references: [id])
  reversedBy LedgerEntry?  @relation("LedgerEntryReversal", fields: [reversedById], references: [id])
  reversals  LedgerEntry[] @relation("LedgerEntryReversal")
  lines      LedgerEntryLine[]
  invoice    Invoice?      @relation("InvoiceLedgerEntry")
  payment    Payment?      @relation("PaymentLedgerEntry")
  bankTransaction BankTransaction? @relation("BankTxnLedgerEntry")

  @@unique([sourceType, sourceId]) // Idempotency: one entry per source event
  @@index([entryDate])
  @@index([period])
  @@index([sourceType])
  @@index([createdAt])
}

/// Individual debit or credit line within a journal entry
model LedgerEntryLine {
  id          String  @id @default(uuid())
  entryId     String
  accountId   String
  debit       Float   @default(0)
  credit      Float   @default(0)
  description String?

  entry   LedgerEntry   @relation(fields: [entryId], references: [id], onDelete: Cascade)
  account LedgerAccount @relation(fields: [accountId], references: [id])

  @@index([entryId])
  @@index([accountId])
}

/// Source document for "money is owed" — vendor bills or customer receivables
model Invoice {
  id               String    @id @default(uuid())
  invoiceNumber    String?
  type             String    // payable, receivable
  category         String    // fabric, trims, service, rent, salary, etc.
  status           String    @default("draft") // draft, confirmed, partially_paid, paid, cancelled

  invoiceDate      DateTime?
  dueDate          DateTime?
  billingPeriod    String?   // "YYYY-MM" — which month this bill covers (for accrual P&L)

  // Counterparty (one of these — always required)
  partyId          String?
  customerId       String?

  // Amounts
  subtotal         Float?
  gstRate          Float?    // GST % snapshot (e.g. 18.0) — recorded at creation/confirm
  gstAmount        Float?
  gstType          String?   // 'igst' or 'cgst_sgst' — determined by customer state vs company state
  cgstAmount       Float?    // Central GST (intra-state: 50% of GST)
  sgstAmount       Float?    // State GST (intra-state: 50% of GST)
  igstAmount       Float?    // Integrated GST (inter-state: 100% of GST)
  tdsRate          Float?    // TDS % snapshot (e.g. 2.0) — recorded at confirm from Party config
  tdsSection       String?   // TDS section snapshot (e.g. "194C") — recorded at confirm
  tdsAmount        Float?    @default(0)
  totalAmount      Float
  paidAmount       Float     @default(0)
  balanceDue       Float     @default(0)

  // Linked records
  orderId          String?

  // File attachment
  fileData         Bytes?
  filePath         String?   // Relative path on server filesystem (e.g. invoices/party/FY/file.pdf)
  fileName         String?
  fileMimeType     String?
  fileSizeBytes    Int?
  fileHash         String?   // SHA-256 of file content for duplicate detection

  // AI parsing metadata (for future AI upload)
  aiRawResponse    Json?
  aiModel          String?
  aiConfidence     Float?

  // Google Drive sync
  driveFileId      String?
  driveUrl         String?
  driveUploadedAt  DateTime?

  // Ledger link
  ledgerEntryId    String?   @unique

  // Tracking
  notes               String?
  settlementBatchRef   String?  // e.g. "RZPY-SET-abc123", "COD-REM-456"
  createdById      String
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  // Relations
  party         Party?         @relation("InvoiceParty", fields: [partyId], references: [id])
  customer      Customer?      @relation("InvoiceCustomer", fields: [customerId], references: [id])
  order         Order?         @relation("InvoiceOrder", fields: [orderId], references: [id])
  ledgerEntry   LedgerEntry?   @relation("InvoiceLedgerEntry", fields: [ledgerEntryId], references: [id])
  createdBy     User           @relation("InvoiceCreator", fields: [createdById], references: [id])
  lines         InvoiceLine[]
  allocations   Allocation[]
  payrollSlip   PayrollSlip?     @relation("PayrollSlipInvoice")
  bankTransactions BankTransaction[] @relation("BankTxnInvoice")

  @@index([type])
  @@index([status])
  @@index([category])
  @@index([billingPeriod])
  @@index([partyId])
  @@index([customerId])
  @@index([orderId])
  @@index([createdAt])
  @@index([invoiceNumber])
  @@index([partyId, invoiceNumber, invoiceDate])
  @@index([fileHash])
  @@index([type, status])         // Dashboard: payable/receivable + status filter
  @@index([type, billingPeriod])  // P&L queries by period
  @@index([partyId, status])      // Party detail: outstanding invoices
  @@index([createdById])          // FK — audit trail
}

/// Line item on an invoice
model InvoiceLine {
  id          String  @id @default(uuid())
  invoiceId   String
  description String?
  hsnCode     String?
  qty         Float?
  unit        String?
  rate        Float?
  amount      Float?
  gstPercent  Float?
  gstAmount   Float?

  // Order line link (for customer_order invoices)
  orderLineId String?                // FK to OrderLine — links invoice line to order line

  // Fabric matching (only populated for category='fabric' invoices)
  fabricColourId String?              // Matched FabricColour
  matchedTxnId   String?  @unique    // Matched existing FabricColourTransaction (1:1)
  matchType      String?             // "auto_matched" | "manual_matched" | "new_entry"

  // Relations
  invoice      Invoice                @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  orderLine    OrderLine?             @relation("InvoiceLineOrderLine", fields: [orderLineId], references: [id])
  fabricColour FabricColour?          @relation("FinanceInvoiceLineFabricColour", fields: [fabricColourId], references: [id])
  matchedTxn   FabricColourTransaction? @relation("FinanceInvoiceLineTxn", fields: [matchedTxnId], references: [id])

  @@index([invoiceId])
  @@index([orderLineId])
  @@index([fabricColourId])
}

/// Sequential invoice numbering — gap-free, concurrency-safe
model InvoiceSequence {
  id            String @id @default(uuid())
  prefix        String @unique  // e.g. "COH" — one row per prefix
  currentNumber Int    @default(0) // Last assigned number
  fiscalYear    String // e.g. "25-26" — current fiscal year

  @@index([prefix, fiscalYear])
}

/// Record of actual money moving
model Payment {
  id              String   @id @default(uuid())
  referenceNumber String?
  direction       String   // outgoing, incoming
  method          String   // bank_transfer, upi, cash, etc.
  status          String   @default("confirmed") // draft, confirmed, cancelled

  amount          Float
  matchedAmount   Float    @default(0)
  unmatchedAmount Float    @default(0)

  paymentDate     DateTime

  // Counterparty (one of these — always required)
  partyId          String?
  customerId       String?

  // File attachment
  fileData      Bytes?
  filePath      String?   // Relative path on server filesystem
  fileName      String?
  fileMimeType  String?
  fileSizeBytes Int?

  // Google Drive sync
  driveFileId      String?
  driveUrl         String?
  driveUploadedAt  DateTime?

  // Ledger link (historical — no longer created for new payments)
  ledgerEntryId String? @unique

  // Accounting: what account was this payment booked to
  debitAccountCode String?

  // Period: "YYYY-MM" IST — for cash-basis grouping
  period String?

  // Tracking
  notes       String?
  createdById String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  party       Party?       @relation("PaymentParty", fields: [partyId], references: [id])
  customer    Customer?    @relation("PaymentCustomer", fields: [customerId], references: [id])
  ledgerEntry LedgerEntry? @relation("PaymentLedgerEntry", fields: [ledgerEntryId], references: [id])
  createdBy   User         @relation("PaymentCreator", fields: [createdById], references: [id])
  allocations     Allocation[]
  bankTransaction BankTransaction? @relation("BankTxnPayment")

  @@index([direction])
  @@index([method])
  @@index([status])
  @@index([partyId])
  @@index([customerId])
  @@index([paymentDate])
  @@index([period])
  @@index([referenceNumber])
  @@index([createdAt])
}

/// Allocation: which bank transactions cover which invoices (bank txn → invoice link)
model Allocation {
  id                String   @id @default(uuid())
  paymentId         String?  // Legacy — will be dropped in Phase 4
  bankTransactionId String?  // New FK — will become required in Phase 4
  invoiceId         String
  amount            Float    // How much of this bank txn goes to this invoice
  notes             String?
  matchedAt         DateTime @default(now())
  matchedById       String

  payment         Payment?         @relation(fields: [paymentId], references: [id], onDelete: Cascade)
  bankTransaction BankTransaction? @relation("BankTxnAllocation", fields: [bankTransactionId], references: [id], onDelete: Cascade)
  invoice         Invoice          @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  matchedBy       User             @relation("AllocationMatcher", fields: [matchedById], references: [id])

  @@unique([paymentId, invoiceId])
  @@unique([bankTransactionId, invoiceId])
  @@index([paymentId])
  @@index([bankTransactionId])
  @@index([invoiceId])
  @@map("Allocation")
}

// ============================================
// WORKER RUN HISTORY
// ============================================

/// Persists every background worker run for visibility into "did anything break overnight?"
model WorkerRun {
  id           String    @id @default(uuid())
  workerName   String    // "tracking_sync", "shopify_sync", etc.
  status       String    @default("running") // "running" | "completed" | "failed"
  startedAt    DateTime
  completedAt  DateTime?
  durationMs   Int?
  result       Json?     // The worker's SyncResult object
  error        String?   // Error message if failed
  triggeredBy  String    @default("scheduled") // "scheduled" | "manual" | "startup"
  createdAt    DateTime  @default(now())

  @@index([workerName, startedAt])
  @@index([createdAt])
}

// ============================================
// PAYROLL & EMPLOYEE MANAGEMENT
// ============================================

/// Employee record with salary structure and statutory details
model Employee {
  id               String    @id @default(uuid())
  name             String
  employeeCode     String?
  phone            String?
  email            String?

  /// Personal details (compliance: PF Form 11, ESIC Form 1)
  dateOfBirth              DateTime?
  gender                   String?   // male, female, other
  fatherOrSpouseName       String?
  maritalStatus            String?   // single, married, divorced, widowed
  currentAddress           String?   @db.Text
  permanentAddress         String?   @db.Text
  emergencyContactName     String?
  emergencyContactPhone    String?
  emergencyContactRelation String?

  dateOfJoining    DateTime?
  dateOfExit       DateTime?

  department       String    // production, office
  designation      String?

  /// Basic salary — HRA (40%), Other (60%), Gross (2x basic) are always computed
  basicSalary      Float

  /// Statutory deduction flags
  pfApplicable     Boolean   @default(false)
  esicApplicable   Boolean   @default(false)
  ptApplicable     Boolean   @default(false)

  /// Bank details
  bankAccountName   String?
  bankAccountNumber String?
  bankIfsc          String?
  bankName          String?

  /// Statutory IDs
  pan              String?
  aadhaar          String?
  uan              String?
  pfNumber         String?   // PF member ID (distinct from UAN)
  esicNumber       String?
  notes            String?   @db.Text  // Free-text notes (DOB discrepancies, etc.)

  /// Links to other models
  partyId          String?   @unique
  tailorId         String?   @unique

  isActive         Boolean   @default(true)
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  party            Party?    @relation(fields: [partyId], references: [id])
  tailor           Tailor?   @relation(fields: [tailorId], references: [id])
  payrollSlips      PayrollSlip[]
  leaveRecords      LeaveRecord[]
  attendanceRecords AttendanceRecord[]
  salaryRevisions   SalaryRevision[]

  @@index([department])
  @@index([isActive])
}

/// Salary revision audit trail — auto-created when salary or statutory flags change
model SalaryRevision {
  id              String    @id @default(uuid())
  employeeId      String
  basicSalary     Float
  pfApplicable    Boolean
  esicApplicable  Boolean
  ptApplicable    Boolean
  effectiveFrom   DateTime
  reason          String?
  createdById     String
  createdAt       DateTime  @default(now())

  employee        Employee  @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  createdBy       User      @relation("SalaryRevisionCreator", fields: [createdById], references: [id])

  @@index([employeeId])
  @@index([effectiveFrom])
  @@index([createdById])
}

/// Exception-based leave record — only absences and half-days are stored
model LeaveRecord {
  id          String   @id @default(uuid())
  employeeId  String
  date        DateTime @db.Date
  type        String   // "absent" | "half_day"
  reason      String?
  source      String   @default("manual") // "manual" | "fingerprint_import"
  createdById String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  employee    Employee @relation(fields: [employeeId], references: [id])
  createdBy   User     @relation("LeaveRecordCreator", fields: [createdById], references: [id])

  @@unique([employeeId, date])
  @@index([date])
}

/// Fingerprint machine attendance record — imported from XLSX reports
model AttendanceRecord {
  id            String   @id @default(uuid())
  employeeId    String
  date          DateTime @db.Date
  status        String   // "P" | "A" | "WO"
  shift         String?  // "GS"
  inTime        String?  // "HH:MM", null if no punch
  outTime       String?
  lateByMins    Int      @default(0)
  earlyByMins   Int      @default(0)
  overtimeMins  Int      @default(0)
  durationMins  Int      @default(0)
  importBatchId String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  employee      Employee @relation(fields: [employeeId], references: [id])

  @@unique([employeeId, date])
  @@index([date])
  @@index([importBatchId])
}

/// Monthly payroll batch header
model PayrollRun {
  id                String    @id @default(uuid())
  month             Int       // 1-12
  year              Int       // e.g. 2026
  status            String    @default("draft") // draft, confirmed, cancelled

  /// Totals (computed from slips)
  totalGross        Float     @default(0)
  totalDeductions   Float     @default(0)
  totalNetPay       Float     @default(0)
  totalEmployerCost Float     @default(0)
  employeeCount     Int       @default(0)

  confirmedAt       DateTime?
  confirmedById     String?
  notes             String?
  createdById       String
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  confirmedBy       User?     @relation("PayrollRunConfirmer", fields: [confirmedById], references: [id])
  createdBy         User      @relation("PayrollRunCreator", fields: [createdById], references: [id])
  slips             PayrollSlip[]

  @@unique([month, year])
  @@index([status])
}

/// Per-employee payroll calculation within a run
model PayrollSlip {
  id                    String   @id @default(uuid())
  payrollRunId          String
  employeeId            String

  /// Days
  daysInMonth           Int
  payableDays           Float    // Can be fractional (e.g. 26.5)
  isManualDays          Boolean  @default(false)

  /// Fixed components (from salary structure at time of run)
  basicFixed            Float
  hraFixed              Float
  otherAllowanceFixed   Float
  grossFixed            Float

  /// Earned (pro-rated by payable days)
  basicEarned           Float
  hraEarned             Float
  otherAllowanceEarned  Float
  grossEarned           Float

  /// Employee deductions
  pfEmployee            Float    @default(0)
  esicEmployee          Float    @default(0)
  professionalTax       Float    @default(0)
  advances              Float    @default(0)
  otherDeductions       Float    @default(0)
  totalDeductions       Float    @default(0)

  /// Net pay
  netPay                Float    @default(0)

  /// Employer contributions
  pfEmployer            Float    @default(0)
  pfAdmin               Float    @default(0)
  esicEmployer          Float    @default(0)
  totalEmployerCost     Float    @default(0)
  costToCompany         Float    @default(0)

  /// Finance link
  invoiceId             String?  @unique

  /// External payroll system data (full register row from RazorpayPayroll etc.)
  registerData          Json?

  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  payrollRun            PayrollRun @relation(fields: [payrollRunId], references: [id], onDelete: Cascade)
  employee              Employee   @relation(fields: [employeeId], references: [id])
  invoice               Invoice?   @relation("PayrollSlipInvoice", fields: [invoiceId], references: [id])

  @@unique([payrollRunId, employeeId])
  @@index([payrollRunId])
  @@index([employeeId])
}

// ============================================
// BANK IMPORT V2
// ============================================

/// Raw bank transaction row — imported from CSV/hardcoded data, then categorized, then optionally posted to ledger
model BankTransaction {
  id                String    @id @default(uuid())
  bank              String    // "hdfc" | "razorpayx" | "hdfc_cc" | "icici_cc"
  txnHash           String    @unique // SHA-256 hash for dedup
  rawData           Json      // Original CSV row as-is
  txnDate           DateTime
  amount            Float
  direction         String    // "debit" | "credit" — from bank's perspective
  narration         String?
  reference         String?   // HDFC ref, RazorpayX payout_id, etc.
  utr               String?
  closingBalance    Float?

  // Period: "YYYY-MM" IST — for cash-flow grouping
  period            String?

  // Categorization (null until categorized)
  counterpartyName  String?
  debitAccountCode  String?
  creditAccountCode String?
  category          String?
  partyId           String?
  matchedInvoiceId  String?

  // AP routing — preserves categorizer's intent even when posted to AP
  intendedDebitAccount String?  // The expense account from categorization
  postingType          String?  // 'single_step' or 'two_step'

  // Payment matching (migrated from Payment model)
  matchedAmount     Float     @default(0)
  unmatchedAmount   Float     @default(0)
  notes             String?

  // File attachment (migrated from Payment model)
  fileData          Bytes?
  filePath          String?   // Relative path on server filesystem
  fileName          String?
  fileMimeType      String?
  fileSizeBytes     Int?

  // Google Drive sync (migrated from Payment model)
  driveFileId       String?
  driveUrl          String?
  driveUploadedAt   DateTime?

  // Status: imported → categorized → posted | skipped | legacy_posted
  status            String    @default("imported")
  skipReason        String?

  // Links to existing records
  ledgerEntryId     String?   @unique
  paymentId         String?   @unique
  legacySourceId    String?   // Old sourceId format for audit matching

  // Batch tracking
  batchId           String?

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  // Relations
  party             Party?        @relation("BankTxnParty", fields: [partyId], references: [id])
  matchedInvoice    Invoice?      @relation("BankTxnInvoice", fields: [matchedInvoiceId], references: [id])
  ledgerEntry       LedgerEntry?  @relation("BankTxnLedgerEntry", fields: [ledgerEntryId], references: [id])
  payment           Payment?      @relation("BankTxnPayment", fields: [paymentId], references: [id])
  batch             BankImportBatch? @relation(fields: [batchId], references: [id])
  allocations       Allocation[]  @relation("BankTxnAllocation")

  @@index([bank, status])
  @@index([txnDate])
  @@index([period])
  @@index([utr])
  @@index([reference])
  @@index([legacySourceId])
  @@index([batchId])
  @@index([partyId])              // FK — party detail page, narration matching
  @@index([matchedInvoiceId])     // FK — invoice reconciliation lookups
  @@index([category])             // Categorization UI filter
  @@index([bank, txnDate])        // Primary query: bank transactions by date range
  @@index([bank, status, period]) // Monthly categorization workflow
}

/// Batch metadata for a single CSV import run
model BankImportBatch {
  id              String    @id @default(uuid())
  bank            String
  fileName        String
  rowCount        Int
  newCount        Int
  skippedCount    Int
  totalDebits     Float
  totalCredits    Float
  openingBalance  Float?
  closingBalance  Float?
  balanceMatched  Boolean?
  createdAt       DateTime  @default(now())

  transactions    BankTransaction[]
}

/// COD remittance from iThink Logistics — links orders to bank deposits
model CodRemittance {
  id                    String    @id @default(uuid())
  remittanceId          String    // iThink's remittance_id
  remittanceDate        DateTime  // Parsed from "20 Apr 2021"

  // Financial breakdown (parsed from string "0.00" to Float)
  codGenerated          Float     @default(0) // Total COD collected from customers
  billAdjusted          Float     @default(0) // Shipping bills deducted
  refundAdjusted        Float     @default(0) // Customer refunds deducted
  transactionCharges    Float     @default(0) // iThink processing fees
  transactionGstCharges Float     @default(0) // GST on processing fees
  walletAmount          Float     @default(0) // Wallet deductions
  advanceHold           Float     @default(0) // Advances held
  codRemitted           Float     @default(0) // NET amount deposited to HDFC

  // Order details (JSON array of { airway_bill_no, order_no, price, delivered_date })
  orderDetails          Json?
  orderCount            Int       @default(0)
  ordersProcessed       Int       @default(0)

  // Source & sync
  source                String    @default("api") // "api" | "csv"
  syncedAt              DateTime  @default(now())

  // Finance bridge: links to HDFC bank deposit when matched
  bankTransactionId     String?   @unique
  matchedAt             DateTime?
  matchConfidence       String?   // "exact_amount" | "approx_date" | "manual"

  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@unique([remittanceId, remittanceDate]) // Idempotency
  @@index([remittanceDate])
  @@index([codRemitted])
}

/// PayU online payment settlements — links prepaid orders to HDFC bank deposits via UTR
model PayuSettlement {
  id                      String    @id @default(uuid())
  settlementId            String    @unique           // PayU's settlement ID
  utrNumber               String                     // Bank UTR for matching
  settlementAmount        Float                      // NET deposited to HDFC
  merchantId              String
  settlementCompletedDate DateTime

  // Per-order breakdown (JSON array from PayU transaction field)
  transactions            Json?
  transactionCount        Int       @default(0)

  // Source
  syncedAt                DateTime  @default(now())

  // Finance bridge: links to HDFC bank deposit when matched
  // NOT unique — multiple settlements can share one UTR (one bank deposit)
  bankTransactionId       String?
  matchedAt               DateTime?
  matchConfidence         String?   // "utr_exact" | "manual"

  createdAt               DateTime  @default(now())
  updatedAt               DateTime  @updatedAt

  @@index([utrNumber])
  @@index([settlementCompletedDate])
}

// ============================================
// MARKETPLACE PAYOUT RECONCILIATION
// ============================================

/// Stores parsed Nykaa (or other marketplace) payout reports for reconciliation
model MarketplacePayoutReport {
  id                    String    @id @default(uuid())
  marketplace           String    // "nykaa_nf" | "nykaa_popup"
  fileName              String
  fileHash              String    // SHA-256 of file content for dedup
  reportPeriod          String    // "YYYY-MM"

  // Summary financials
  grossRevenue          Float     @default(0)
  totalCommission       Float     @default(0)
  bannerDeduction       Float     @default(0)
  shippingCharges       Float     @default(0)
  returnCharges         Float     @default(0)
  tdsAmount             Float     @default(0)
  otherIncome           Float     @default(0)
  netPayout             Float     @default(0)

  // Order stats
  orderCount            Int       @default(0)
  deliveredCount        Int       @default(0)
  returnCount           Int       @default(0)
  cancelledCount        Int       @default(0)

  // Reconciliation details (JSON)
  orderLines            Json?     // Parsed order lines from xlsx
  matchedOrders         Json?     // { matched: [...], unmatched: [...] }
  bankMatchResult       Json?     // { bankTxnId, amount, narration } or null

  // Linked finance records (populated on confirm)
  revenueInvoiceId      String?
  commissionInvoiceId   String?
  promoInvoiceId        String?
  bankTransactionId     String?

  // Status: draft → confirmed → cancelled
  status                String    @default("draft")

  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@unique([marketplace, fileHash])
  @@index([marketplace])
  @@index([reportPeriod])
  @@index([status])
}

// ============================================
// DOMAIN EVENT LOG
// ============================================

/// Unified event stream for all business domains — enables activity feed, audit timeline, analytics
model DomainEvent {
  id         String   @id @default(uuid())
  domain     String   // orders, customers, returns, finance, shipping, inventory, production
  event      String   // order.created, payment.received, shipment.delivered, etc.
  entityType String   // Order, Customer, ReturnLine, BankTransaction, etc.
  entityId   String   // UUID of the entity
  summary    String   // Human-readable: "Order #4521 — ₹2,450 via Shopify"
  meta       Json?    // Structured payload (channel, items, amounts, etc.)
  actorId    String?  // userId who triggered it (null for system/webhook events)
  createdAt  DateTime @default(now())

  @@index([domain, createdAt])
  @@index([entityType, entityId])
  @@index([event, createdAt])
  @@index([createdAt])
  @@index([actorId])
}

// ============================================
// EMAIL LOG
// ============================================

/// Tracks every email sent from the system — delivery status, content, domain linking
model EmailLog {
  id            String    @id @default(uuid())
  messageId     String?   @unique // Provider message ID (SES/Resend) for tracking

  // Recipients & Content
  toEmail       String
  fromEmail     String
  subject       String
  htmlContent   String    // Full HTML body
  textContent   String?   // Plain text alternative

  // Provider & Routing
  provider      String    // "ses" | "resend"
  templateKey   String?   // "return-created", "order-confirmation", "shipping-update"

  // Status tracking
  status        String    @default("pending") // pending → sent → delivered → bounced → failed → complained
  sentAt        DateTime?
  deliveredAt   DateTime?
  error         String?   // Error message if failed

  // Domain linking (polymorphic)
  entityType    String?   // "Order", "ReturnPrimeRequest", "Invoice", "Customer"
  entityId      String?   // UUID of the linked entity

  metadata      Json?     // Extra context: { retryCount, source, etc. }

  // Audit
  createdById   String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  @@index([toEmail])
  @@index([status])
  @@index([templateKey])
  @@index([entityType, entityId])
  @@index([createdAt])
  @@index([messageId])
}

/// Saved audience segment for campaigns and targeting
model Audience {
  id            String   @id @default(uuid())
  name          String
  description   String?
  filters       Json     // AudienceFilters — see audienceFilters.ts for schema
  customerCount Int      @default(0)

  // Audit
  createdById   String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  campaigns     EmailCampaign[]

  @@index([createdAt])
}

/// Email marketing campaign
model EmailCampaign {
  id                String    @id @default(uuid())
  name              String    // Internal campaign name
  subject           String    // Email subject line
  preheaderText     String?   // Preview text shown in inbox

  // Content
  htmlContent       String?   // Full email HTML (AI-generated or manually edited)
  shopifyProductIds Json?     // String[] of Shopify product IDs to feature
  sourceId          String?   // FK to another campaign used as starting point

  // Status
  status            String    @default("draft") // draft | scheduled | sending | sent | cancelled

  // Audience
  audienceFilter    Json?     // { tiers: [], tags: [], lastPurchaseDays: number }
  audienceId        String?   // FK to saved Audience
  audience          Audience? @relation(fields: [audienceId], references: [id])
  recipientCount    Int       @default(0)

  // Stats (denormalized, updated by webhooks)
  sentCount         Int       @default(0)
  deliveredCount    Int       @default(0)
  openCount         Int       @default(0)
  clickCount        Int       @default(0)
  bounceCount       Int       @default(0)
  unsubscribeCount  Int       @default(0)

  // UTM Tracking (per-campaign, editable)
  utmSource         String    @default("email")
  utmMedium         String    @default("campaign")
  utmCampaign       String?   // Auto-slugified from name, editable
  utmContent        String?   // Optional, for variant tracking
  utmTerm           String?   // Optional

  // Scheduling
  scheduledAt       DateTime?
  sentAt            DateTime?

  // Audit
  createdById       String?
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  recipients        EmailCampaignRecipient[]

  @@index([status])
  @@index([createdAt])
  @@index([sentAt])
}

/// Individual recipient record for a campaign send
model EmailCampaignRecipient {
  id          String    @id @default(uuid())
  campaignId  String
  campaign    EmailCampaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)
  customerId  String
  customer    Customer  @relation(fields: [customerId], references: [id])
  email       String    // Snapshot of customer email at send time

  // Delivery status
  status      String    @default("pending") // pending | sent | delivered | opened | clicked | bounced | complained | unsubscribed
  sentAt      DateTime?
  deliveredAt DateTime?
  openedAt    DateTime?
  clickedAt   DateTime?

  // Link to actual email log
  emailLogId  String?   @unique

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@unique([campaignId, customerId]) // One entry per customer per campaign
  @@index([campaignId, status])
  @@index([customerId])
  @@index([email])
}

/// Persisted demand forecast runs
model DemandForecast {
  id            String   @id @default(uuid())
  createdAt     DateTime @default(now())
  createdById   String?

  /// Number of weeks forecasted
  forecastWeeks Int      @default(8)

  /// Full forecast JSON (products, fabric requirements, purchase orders, etc.)
  data          Json

  /// Claude AI analysis text (populated after user requests it)
  aiAnalysis    String?

  /// Summary fields for quick listing
  totalUnits    Float?
  productCount  Int?
  shortfallCount Int?

  @@index([createdAt])
}

model StyleMeasurement {
  id               String   @id @default(uuid())
  styleCode        String   @unique
  unit             String   @default("in")
  measurements     Json     @default("{}")
  fitComments      Json     @default("[]")
  sampleSize       String?
  isFullyGraded    Boolean  @default(false)
  sizeEquivalents  Json?    /// UK/US/EU equivalents per size, e.g. { "M": { "uk": 10, "us": 6, "eu": 38 } }
  source           String?
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
}

// ============================================
// STOREFRONT ANALYTICS (Custom Web Pixel)
// ============================================

/// Raw storefront events from Shopify Custom Web Pixel — first-party, unsampled click-level data
model StorefrontEvent {
  id              String   @id @default(uuid())
  eventName       String
  eventTime       DateTime
  createdAt       DateTime @default(now())
  sessionId       String
  visitorId       String
  pageUrl         String?
  referrer        String?
  utmSource       String?
  utmMedium       String?
  utmCampaign     String?
  utmContent      String?
  utmTerm         String?
  productId       String?
  productTitle    String?
  variantId       String?
  variantTitle    String?
  collectionId    String?
  collectionTitle String?
  searchQuery     String?
  cartValue       Float?
  orderValue      Float?
  userAgent       String?
  screenWidth     Int?
  screenHeight    Int?
  deviceType      String?
  country         String?
  region          String?
  city            String?
  latitude        String?
  longitude       String?
  clientIp        String?
  rawData         Json?

  @@index([eventName, createdAt])
  @@index([sessionId])
  @@index([visitorId, createdAt])
  @@index([createdAt])
  @@index([productId, createdAt])
}
