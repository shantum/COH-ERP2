// Creatures of Habit ERP - Database Schema (PostgreSQL)
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// USERS & AUTH
// ============================================

model User {
  id        String   @id @default(uuid())
  email     String   @unique
  password  String
  name      String
  role      String   @default("staff")
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  inventoryTransactions  InventoryTransaction[]
  fabricTransactions     FabricTransaction[]
  returnStatusHistory    ReturnStatusHistory[]
  processedRepackItems   RepackingQueueItem[]   @relation("RepackingProcessor")
  createdWriteOffs       WriteOffLog[]          @relation("WriteOffCreator")
  rtoInwardedLines       OrderLine[]            @relation("RtoInwardedBy")
  customizedLines        OrderLine[]            @relation("CustomizedBy")
}

// ============================================
// PRODUCTS HIERARCHY
// ============================================

model Product {
  id                        String   @id @default(uuid())
  name                      String
  styleCode                 String?  @unique // Style identifier (e.g., "LMD" for Linen Midi Dress)
  category                  String   // dress, top, bottom, outerwear, accessory
  productType               String   // basic, seasonal, limited
  gender                    String   @default("unisex") // mens, womens, unisex
  fabricTypeId              String?  // Default fabric type for this product (e.g., "Linen 60 Lea")
  baseProductionTimeMins    Int      @default(60)
  defaultFabricConsumption  Float?   // Default fabric consumption for SKUs (fallback)
  imageUrl                  String?  // Main product image URL (from Shopify)
  isActive                  Boolean  @default(true)
  createdAt                 DateTime @default(now())
  updatedAt                 DateTime @updatedAt

  // Shopify integration
  shopifyProductId String? @unique // Shopify product ID
  shopifyHandle    String?         // Shopify handle (URL slug)

  // Return/exchange stats (aggregated from SKUs)
  returnCount   Int @default(0)
  exchangeCount Int @default(0)
  writeOffCount Int @default(0)

  fabricType FabricType? @relation(fields: [fabricTypeId], references: [id])
  variations Variation[]

  @@index([fabricTypeId])
  @@index([category])
  @@index([shopifyHandle])
}

model Variation {
  id            String  @id @default(uuid())
  productId     String
  colorName     String  // e.g., "Mustard", "Wildflower Blue"
  standardColor String? // e.g., "Yellow", "Blue" - for analytics/grouping
  colorHex      String?
  fabricId      String
  imageUrl      String? // Color-specific image URL (from Shopify)
  isActive      Boolean @default(true)

  product Product @relation(fields: [productId], references: [id])
  fabric  Fabric  @relation(fields: [fabricId], references: [id])
  skus    Sku[]

  @@unique([productId, colorName])
  @@index([productId])
  @@index([fabricId])
}

model Sku {
  id                String  @id @default(uuid())
  skuCode           String  @unique // Also used as barcode for scanning
  variationId       String
  size              String  // XS, S, M, L, XL, 2XL, 3XL, 4XL, Free
  fabricConsumption Float   @default(1.5)
  mrp               Float
  targetStockQty    Int     @default(10)
  targetStockMethod String  @default("day14") // day7, day14, day28, manual
  isActive          Boolean @default(true)

  // Shopify integration
  shopifyInventoryItemId String?
  shopifyVariantId       String?

  // Return/exchange stats
  returnCount   Int @default(0)
  exchangeCount Int @default(0)
  writeOffCount Int @default(0)

  // Custom SKU tracking
  isCustomSku         Boolean  @default(false)  // True for custom pieces
  parentSkuId         String?                    // Links to base SKU
  parentSku           Sku?     @relation("CustomSkus", fields: [parentSkuId], references: [id])
  customSkus          Sku[]    @relation("CustomSkus")
  customizationCount  Int      @default(0)       // Counter for next C01, C02...

  // Customization details (only set for custom SKUs)
  customizationType   String?   // 'length', 'size', 'measurements', 'other'
  customizationValue  String?   // e.g., "-2 inches"
  customizationNotes  String?
  linkedOrderLineId   String?   @unique          // The order line this was made for

  variation             Variation              @relation(fields: [variationId], references: [id])
  inventoryTransactions InventoryTransaction[]
  orderLines            OrderLine[]
  productionBatches     ProductionBatch[]
  skuCosting            SkuCosting?
  returnRequestLines    ReturnRequestLine[]    @relation("ReturnedSku")
  exchangeRequestLines  ReturnRequestLine[]    @relation("ExchangeSku")
  replacementItems      ReplacementItem[]      // NEW: When this SKU is wanted as replacement
  feedbackProductLinks  FeedbackProductLink[]
  shopifyInventoryCache ShopifyInventoryCache?
  repackingQueueItems   RepackingQueueItem[]
  writeOffLogs          WriteOffLog[]

  @@index([variationId])
  @@index([parentSkuId])
  @@index([isCustomSku])
}

model SkuCosting {
  skuId           String   @id
  fabricCost      Float
  laborTimeMins   Int
  laborRatePerMin Float
  laborCost       Float
  packagingCost   Float    @default(0)
  otherCost       Float    @default(0)
  totalCogs       Float
  lastUpdated     DateTime @default(now())

  sku Sku @relation(fields: [skuId], references: [id])
}

model CostConfig {
  id                   String   @id @default(uuid())
  laborRatePerMin      Float    @default(2.50)
  defaultPackagingCost Float    @default(50)
  lastUpdated          DateTime @default(now())
}

// ============================================
// FABRIC MANAGEMENT
// ============================================

model FabricType {
  id              String  @id @default(uuid())
  name            String
  composition     String?
  unit            String  // meter, kg
  avgShrinkagePct Float   @default(0)

  fabrics  Fabric[]
  products Product[]
}

model Fabric {
  id            String  @id @default(uuid())
  fabricTypeId  String
  name          String
  colorName     String  // e.g., "Mustard", "Ocean Blue"
  standardColor String? // e.g., "Yellow", "Blue" - for analytics/grouping
  colorHex      String?
  costPerUnit   Float
  supplierId   String?
  leadTimeDays Int     @default(14)
  minOrderQty  Float   @default(10)
  isActive     Boolean @default(true)

  fabricType   FabricType          @relation(fields: [fabricTypeId], references: [id])
  supplier     Supplier?           @relation(fields: [supplierId], references: [id])
  variations          Variation[]
  transactions        FabricTransaction[]
  fabricOrders        FabricOrder[]
  reconciliationItems FabricReconciliationItem[]

  @@index([fabricTypeId])
  @@index([supplierId])
}

model Supplier {
  id          String   @id @default(uuid())
  name        String
  contactName String?
  email       String?
  phone       String?
  address     String?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())

  fabrics            Fabric[]
  fabricOrders       FabricOrder[]
  fabricTransactions FabricTransaction[]
}

model FabricTransaction {
  id          String   @id @default(uuid())
  fabricId    String
  txnType     String   // inward, outward
  qty         Float
  unit        String   // meter, kg
  reason      String   // supplier_receipt, production, shrinkage, damage, adjustment
  costPerUnit Float?   // Cost per unit for inward transactions
  supplierId  String?  // Supplier for inward transactions
  referenceId String?
  notes       String?
  createdById String
  createdAt   DateTime @default(now())

  fabric    Fabric    @relation(fields: [fabricId], references: [id])
  createdBy User      @relation(fields: [createdById], references: [id])
  supplier  Supplier? @relation(fields: [supplierId], references: [id])

  @@index([fabricId])
  @@index([txnType])
  @@index([createdAt])
  @@index([fabricId, createdAt])  // Compound: fabric transaction history
}

model FabricOrder {
  id           String    @id @default(uuid())
  fabricId     String
  supplierId   String
  qtyOrdered   Float
  unit         String    // meter, kg
  costPerUnit  Float
  totalCost    Float
  orderDate    DateTime  @default(now())
  expectedDate DateTime?
  receivedDate DateTime?
  qtyReceived  Float?
  status       String    @default("ordered") // ordered, partial, received, cancelled
  notes        String?

  fabric   Fabric   @relation(fields: [fabricId], references: [id])
  supplier Supplier @relation(fields: [supplierId], references: [id])

  @@index([fabricId])
  @@index([supplierId])
  @@index([status])
}

// ============================================
// INVENTORY
// ============================================

model InventoryTransaction {
  id                String   @id @default(uuid())
  skuId             String
  txnType           String   // inward, outward
  qty               Int
  reason            String   // production, sale, return_receipt, damage, adjustment, transfer
  referenceId       String?
  notes             String?
  warehouseLocation String?
  createdById       String
  createdAt         DateTime @default(now())

  sku       Sku  @relation(fields: [skuId], references: [id])
  createdBy User @relation(fields: [createdById], references: [id])

  @@index([skuId])
  @@index([txnType])
  @@index([createdAt])
}

// ============================================
// CUSTOMERS
// ============================================

model Customer {
  id                String    @id @default(uuid())
  shopifyCustomerId String?   @unique
  email             String    @unique
  phone             String?
  firstName         String?
  lastName          String?
  defaultAddress    String?   // JSON stored as string
  tags              String?   // Comma-separated
  acceptsMarketing  Boolean   @default(false)
  firstOrderDate    DateTime?
  lastOrderDate     DateTime?
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  // Return/exchange stats
  returnCount   Int @default(0)
  exchangeCount Int @default(0)

  orders         Order[]
  returnRequests ReturnRequest[]
  feedback       Feedback[]
}

// ============================================
// ORDERS
// ============================================

model Order {
  id              String    @id @default(uuid())
  orderNumber     String    @unique
  shopifyOrderId  String?   @unique
  channel         String    @default("shopify") // shopify, amazon, offline, custom
  customerId      String?
  customerName    String
  customerEmail   String?
  customerPhone   String?
  shippingAddress String?   // JSON stored as string
  orderDate       DateTime  @default(now())
  customerNotes   String?
  internalNotes   String?
  paymentMethod   String?   // COD, Prepaid, etc.
  status          String    @default("open") // open, shipped, delivered, cancelled, returned
  isArchived      Boolean   @default(false)
  archivedAt      DateTime?
  awbNumber       String?
  courier         String?
  shippedAt       DateTime?
  deliveredAt     DateTime?
  rtoInitiatedAt  DateTime?  // When RTO was initiated (failed delivery)
  rtoReceivedAt   DateTime?  // When RTO package was received back
  totalAmount     Float

  // iThink Logistics tracking fields
  trackingStatus       String?   // in_transit, out_for_delivery, delivered, delivery_delayed, rto_initiated, rto_in_transit, rto_delivered
  expectedDeliveryDate DateTime? // Expected delivery date from courier
  deliveryAttempts     Int       @default(0) // OFD count - number of delivery attempts
  lastScanStatus       String?   // Latest tracking scan status text
  lastScanLocation     String?   // Latest tracking scan location
  lastScanAt           DateTime? // When the last scan occurred
  lastTrackingUpdate   DateTime? // When we last fetched tracking from API
  courierStatusCode    String?   // Raw status code from courier (e.g., IT, OFD, DL, UD)

  // COD Remittance fields
  codRemittedAt     DateTime? // When COD was remitted by logistics partner
  codRemittanceUtr  String?   // Bank UTR reference for COD remittance
  codRemittedAmount Float?    // Actual COD amount remitted

  // COD Shopify sync status
  codShopifySyncStatus String?   // pending, synced, failed, manual_review
  codShopifySyncError  String?   // Error message if sync failed
  codShopifySyncedAt   DateTime? // When payment was synced to Shopify

  discountCode    String?   // Discount/coupon code used on the order
  createdAt       DateTime  @default(now())
  syncedAt        DateTime?
  shopifyFulfillmentStatus String? // unfulfilled, partial, fulfilled
  shopifyData     String?   // DEPRECATED: Use ShopifyOrderCache instead. Kept for Railway migration compatibility.

  customer         Customer?           @relation(fields: [customerId], references: [id])
  shopifyCache     ShopifyOrderCache?  @relation(fields: [shopifyOrderId], references: [id])
  orderLines       OrderLine[]
  returnRequests   ReturnRequest[]     @relation("OriginalOrder")
  exchangeRequests ReturnRequest[]     @relation("ExchangeOrder")

  @@index([customerId])
  @@index([status])
  @@index([orderDate])
  @@index([isArchived])
  @@index([status, orderDate])      // Compound: filter by status + sort by date
  @@index([customerId, orderDate])  // Compound: customer order history
}

model OrderLine {
  id                String    @id @default(uuid())
  orderId           String
  shopifyLineId     String?
  skuId             String
  qty               Int
  unitPrice         Float
  lineStatus        String    @default("pending") // pending, allocated, picked, packed, shipped
  allocatedAt       DateTime?
  pickedAt          DateTime?
  packedAt          DateTime?
  shippedAt         DateTime?
  inventoryTxnId    String?
  productionBatchId String?
  notes             String?

  // Customization tracking
  isCustomized      Boolean   @default(false)
  isNonReturnable   Boolean   @default(false)
  originalSkuId     String?                       // Preserves reference to base SKU
  customizedAt      DateTime?
  customizedById    String?

  // RTO Reconciliation fields (only populated for RTO orders)
  rtoCondition      String?   // null, unopened, good, damaged, wrong_product
  rtoInwardedAt     DateTime?
  rtoInwardedById   String?
  rtoNotes          String?

  order              Order               @relation(fields: [orderId], references: [id])
  sku                Sku                 @relation(fields: [skuId], references: [id])
  productionBatch    ProductionBatch?    @relation(fields: [productionBatchId], references: [id])
  returnRequestLines ReturnRequestLine[]
  rtoInwardedBy      User?               @relation("RtoInwardedBy", fields: [rtoInwardedById], references: [id])
  customizedBy       User?               @relation("CustomizedBy", fields: [customizedById], references: [id])

  @@index([orderId])
  @@index([skuId])
  @@index([lineStatus])
  @@index([productionBatchId])
  @@index([lineStatus, orderId])  // Compound: filter lines by status within order
  @@index([rtoInwardedById])
  @@index([customizedById])
}

// ============================================
// RETURNS & EXCHANGES
// ============================================

model ReturnRequest {
  id              String   @id @default(uuid())
  requestNumber   String   @unique
  requestType     String   // DEPRECATED: Use resolutionType. Kept for backward compat. Values: return, exchange
  originalOrderId String
  customerId      String?
  status          String   @default("pending_pickup") // pending_pickup, in_transit, received, processing, completed, cancelled
  reasonCategory  String   // size_issue, color_mismatch, quality_defect, wrong_item, changed_mind, damaged_in_transit, other
  reasonDetails   String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // NEW: Resolution type (replaces requestType)
  // refund = full refund, exchange_same = same value item, exchange_up = higher value (+pay), exchange_down = lower value (+refund diff)
  resolution      String   @default("refund") // refund, exchange_same, exchange_up, exchange_down

  // Value tracking
  returnValue       Float?    // Value of items being returned
  replacementValue  Float?    // Value of replacement items (0 for refund)
  valueDifference   Float?    // Positive = customer pays, Negative = refund difference

  // Resolution outcomes
  refundAmount        Float?    // Amount to refund (full or difference)
  refundProcessedAt   DateTime? // When refund was issued
  paymentAmount       Float?    // Amount customer needs to pay (for exchange_up)
  paymentCollectedAt  DateTime? // When payment was collected
  resolutionNotes     String?

  // Exchange order linking
  exchangeOrderId    String?   // Links to the replacement order

  // Shipment tracking timestamps
  reverseInTransitAt DateTime? // NEW: When reverse pickup confirmed (allows early-ship)
  reverseReceived    Boolean   @default(false)  // Customer's return received at warehouse
  reverseReceivedAt  DateTime?
  forwardShippedAt   DateTime? // NEW: When replacement shipped
  forwardDelivered   Boolean   @default(false)  // Replacement delivered to customer
  forwardDeliveredAt DateTime?

  originalOrder       Order                 @relation("OriginalOrder", fields: [originalOrderId], references: [id])
  exchangeOrder       Order?                @relation("ExchangeOrder", fields: [exchangeOrderId], references: [id])
  customer            Customer?             @relation(fields: [customerId], references: [id])
  lines               ReturnRequestLine[]
  replacementItems    ReplacementItem[]     // NEW: Items customer wants as replacement
  shipping            ReturnShipping[]
  statusHistory       ReturnStatusHistory[]
  repackingQueueItems RepackingQueueItem[]

  @@index([originalOrderId])
  @@index([customerId])
  @@index([status])
  @@index([resolution])
  @@index([exchangeOrderId])
}

model ReturnRequestLine {
  id                  String  @id @default(uuid())
  requestId           String
  originalOrderLineId String?
  skuId               String
  qty                 Int
  unitPrice           Float?  // Price of item being returned (for value calc)
  exchangeSkuId       String? // DEPRECATED: Use ReplacementItem model instead
  exchangeQty         Int?    // DEPRECATED: Use ReplacementItem model instead
  itemCondition       String? // good, used, damaged, wrong_product (set when received)
  inspectionNotes     String?

  request           ReturnRequest @relation(fields: [requestId], references: [id])
  originalOrderLine OrderLine?    @relation(fields: [originalOrderLineId], references: [id])
  sku               Sku           @relation("ReturnedSku", fields: [skuId], references: [id])
  exchangeSku       Sku?          @relation("ExchangeSku", fields: [exchangeSkuId], references: [id])

  @@index([requestId])
  @@index([skuId])
}

// NEW: Tracks what the customer wants as replacement (for exchanges)
model ReplacementItem {
  id            String  @id @default(uuid())
  requestId     String
  skuId         String
  qty           Int
  unitPrice     Float   // Price of replacement item

  request ReturnRequest @relation(fields: [requestId], references: [id])
  sku     Sku           @relation(fields: [skuId], references: [id])

  @@index([requestId])
  @@index([skuId])
}

model ReturnShipping {
  id                String    @id @default(uuid())
  requestId         String
  direction         String    // reverse, forward
  courier           String?
  awbNumber         String?
  pickupAddress     String?   // JSON stored as string
  pickupScheduledAt DateTime?
  pickedUpAt        DateTime?
  receivedAt        DateTime?
  shippedAt         DateTime?
  deliveredAt       DateTime?
  status            String    @default("scheduled") // scheduled, picked_up, in_transit, delivered, failed
  notes             String?

  request ReturnRequest @relation(fields: [requestId], references: [id])

  @@index([requestId])
}

model ReturnStatusHistory {
  id          String   @id @default(uuid())
  requestId   String
  fromStatus  String
  toStatus    String
  changedById String
  notes       String?
  createdAt   DateTime @default(now())

  request   ReturnRequest @relation(fields: [requestId], references: [id])
  changedBy User          @relation(fields: [changedById], references: [id])

  @@index([requestId])
}

// ============================================
// CUSTOMER FEEDBACK
// ============================================

model Feedback {
  id           String   @id @default(uuid())
  customerId   String?
  orderId      String?
  orderLineId  String?
  source       String   // post_delivery, review_request, support, manual, shopify_review
  feedbackType String   // rating, review, complaint, suggestion, praise
  status       String   @default("new") // new, acknowledged, actioned, resolved, archived
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  customer     Customer?             @relation(fields: [customerId], references: [id])
  ratings      FeedbackRating[]
  content      FeedbackContent?
  media        FeedbackMedia[]
  productLinks FeedbackProductLink[]
  tags         FeedbackTag[]

  @@index([customerId])
  @@index([status])
}

model FeedbackRating {
  id         String @id @default(uuid())
  feedbackId String
  dimension  String // overall, quality, fit, comfort, value, packaging
  score      Int

  feedback Feedback @relation(fields: [feedbackId], references: [id])
}

model FeedbackContent {
  id             String   @id @default(uuid())
  feedbackId     String   @unique
  title          String?
  body           String?
  pros           String?
  cons           String?
  wouldRecommend Boolean?

  feedback Feedback @relation(fields: [feedbackId], references: [id])
}

model FeedbackMedia {
  id         String  @id @default(uuid())
  feedbackId String
  mediaType  String
  url        String
  caption    String?

  feedback Feedback @relation(fields: [feedbackId], references: [id])
}

model FeedbackProductLink {
  id          String  @id @default(uuid())
  feedbackId  String
  productId   String?
  variationId String?
  skuId       String?

  feedback Feedback @relation(fields: [feedbackId], references: [id])
  sku      Sku?     @relation(fields: [skuId], references: [id])
}

model FeedbackTag {
  id         String @id @default(uuid())
  feedbackId String
  tag        String

  feedback Feedback @relation(fields: [feedbackId], references: [id])
}

// ============================================
// PRODUCTION
// ============================================

model Tailor {
  id                String   @id @default(uuid())
  name              String
  specializations   String?  // Comma-separated: dress,top,bottom
  dailyCapacityMins Int      @default(480)
  isActive          Boolean  @default(true)
  createdAt         DateTime @default(now())

  productionBatches ProductionBatch[]
}

model ProductionBatch {
  id                String    @id @default(uuid())
  batchCode         String?   @unique // Human-readable code: YYYYMMDD-001
  batchDate         DateTime  @default(now())
  tailorId          String?
  skuId             String
  qtyPlanned        Int
  qtyCompleted      Int       @default(0)
  priority          String    // order_fulfillment, stock_replenishment
  sourceOrderLineId String?
  status            String    @default("planned") // planned, in_progress, completed, cancelled
  notes             String?
  createdAt         DateTime  @default(now())
  completedAt       DateTime?

  tailor     Tailor?     @relation(fields: [tailorId], references: [id])
  sku        Sku         @relation(fields: [skuId], references: [id])
  orderLines OrderLine[]

  @@index([skuId])
  @@index([tailorId])
  @@index([batchDate])
  @@index([status])
  @@index([batchDate, batchCode])  // For efficient batch code generation query
}

// ============================================
// REPACKING & WRITE-OFFS
// ============================================

model RepackingQueueItem {
  id              String    @id @default(uuid())
  skuId           String
  qty             Int       @default(1)
  returnRequestId String?   // Link to return that created this
  returnLineId    String?   // Specific return line
  status          String    @default("pending") // pending, inspecting, repacking, ready, write_off
  condition       String    // unused, used, damaged, defective, destroyed
  inspectionNotes String?
  qcComments      String?   // QC comments when accepting/rejecting
  writeOffReason  String?   // size_issue, quality_defect, destroyed, wrong_product
  createdAt       DateTime  @default(now())
  processedAt     DateTime?
  processedById   String?

  sku           Sku            @relation(fields: [skuId], references: [id])
  returnRequest ReturnRequest? @relation(fields: [returnRequestId], references: [id])
  processedBy   User?          @relation("RepackingProcessor", fields: [processedById], references: [id])

  @@index([skuId])
  @@index([status])
  @@index([returnRequestId])
}

model WriteOffLog {
  id          String   @id @default(uuid())
  skuId       String
  qty         Int
  reason      String   // defective, destroyed, wrong_product, expired, other
  sourceType  String   // return, production, inventory_audit
  sourceId    String?  // RepackingQueueItem.id or other reference
  notes       String?
  costValue   Float?   // For financial tracking
  createdById String
  createdAt   DateTime @default(now())

  sku       Sku  @relation(fields: [skuId], references: [id])
  createdBy User @relation("WriteOffCreator", fields: [createdById], references: [id])

  @@index([skuId])
  @@index([reason])
  @@index([createdAt])
}

// ============================================
// SHOPIFY INTEGRATION
// ============================================

model ShopifyInventoryCache {
  skuId                  String   @id
  shopifyInventoryItemId String
  availableQty           Int
  lastSynced             DateTime @default(now())

  sku Sku @relation(fields: [skuId], references: [id])
}

model ShopifyProductCache {
  id              String    @id // shopifyProductId
  rawData         String    // Complete Shopify product JSON
  title           String?   // Extracted for quick lookup
  handle          String?   // Shopify handle
  lastWebhookAt   DateTime  @default(now())
  webhookTopic    String?   // products/create, products/update, etc.
  processedAt     DateTime? // When synced to Product table
  processingError String?   // If sync failed, store error
  createdAt       DateTime  @default(now())

  @@index([handle])
  @@index([processedAt])
  @@index([lastWebhookAt])
}

model StockAlert {
  id        String   @id @default(uuid())
  skuId     String
  alertType String
  details   String?
  createdAt DateTime @default(now())
  resolved  Boolean  @default(false)

  @@index([skuId])
  @@index([resolved])
}

// ============================================
// SYSTEM SETTINGS
// ============================================

model SystemSetting {
  key       String   @id
  value     String
  updatedAt DateTime @updatedAt
}

// ============================================
// BACKGROUND SYNC JOBS
// ============================================

model SyncJob {
  id            String    @id @default(uuid())
  jobType       String    // orders, customers, products
  status        String    @default("pending") // pending, running, completed, failed, cancelled

  // Configuration
  dateFilter    String?   // e.g., "last_90_days"
  daysBack      Int?      // Number of days to sync
  syncMode      String?   // 'populate' (skip existing) | 'update' (refresh stale) | null (legacy upsert)
  staleAfterMins Int?     // For update mode: re-sync orders updated in Shopify within last X mins

  // Progress tracking
  totalRecords  Int?      // Total records to process (from Shopify count)
  processed     Int       @default(0) // Records processed so far
  created       Int       @default(0) // Records created
  updated       Int       @default(0) // Records updated
  skipped       Int       @default(0) // Records skipped
  errors        Int       @default(0) // Records with errors

  // Resume capability
  lastProcessedId String? // Last Shopify ID processed (for resume)
  currentBatch    Int     @default(0) // Current batch number

  // Error tracking
  errorLog      String?   // JSON array of errors (truncated)
  lastError     String?   // Most recent error message

  // Timestamps
  startedAt     DateTime?
  completedAt   DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  @@index([status])
  @@index([jobType])
  @@index([createdAt])
}

// ============================================
// SHOPIFY ORDER CACHE
// ============================================

model ShopifyOrderCache {
  id                String    @id // shopifyOrderId
  rawData           String    // Complete Shopify order JSON (kept for rare fields)

  // Extracted fields for quick lookup (no JSON parsing needed)
  orderNumber       String?
  financialStatus   String?   // paid, pending, refunded, etc.
  fulfillmentStatus String?   // unfulfilled, partial, fulfilled

  // Commonly-needed Shopify fields (extracted at cache time)
  discountCodes     String?   // Comma-separated discount codes
  customerNotes     String?   // Shopify order.note
  paymentMethod     String?   // Calculated: COD or Prepaid
  tags              String?   // Comma-separated order tags

  // Tracking info from fulfillments
  trackingNumber    String?   // AWB number
  trackingCompany   String?   // Courier name
  trackingUrl       String?   // Tracking URL from Shopify
  shippedAt         DateTime? // When fulfilled
  shipmentStatus    String?   // in_transit, out_for_delivery, delivered, etc.
  deliveredAt       DateTime? // When delivered (from Shopify)
  fulfillmentUpdatedAt DateTime? // Last fulfillment status update

  // Shipping address (flattened for common queries)
  shippingCity      String?
  shippingState     String?
  shippingCountry   String?

  // Metadata
  lastWebhookAt     DateTime  @default(now())
  webhookTopic      String?   // orders/create, orders/updated, etc.
  processedAt       DateTime? // When synced to Order table
  processingError   String?   // If sync failed, store error
  createdAt         DateTime  @default(now())

  // Relation to Order
  order             Order?

  @@index([orderNumber])
  @@index([processedAt])
  @@index([lastWebhookAt])
}

// ============================================
// WEBHOOK MANAGEMENT
// ============================================

model WebhookLog {
  id              String    @id @default(uuid())
  webhookId       String    @unique // X-Shopify-Webhook-Id header (deduplication key)
  topic           String    // orders/create, orders/updated, etc.
  resourceId      String?   // Shopify resource ID (order/product/customer ID)
  status          String    @default("received") // received, processing, processed, failed
  responseCode    Int?      // HTTP response code sent back
  processingTime  Int?      // ms to process
  error           String?   // Error message if failed
  receivedAt      DateTime  @default(now())
  processedAt     DateTime?

  @@index([webhookId])
  @@index([topic])
  @@index([resourceId])
  @@index([receivedAt])
}

model FailedSyncItem {
  id            String    @id @default(uuid())
  itemType      String    // order, product, customer
  resourceId    String    // Shopify resource ID
  rawData       String?   // JSON payload that failed
  error         String    // Error message
  retryCount    Int       @default(0)
  maxRetries    Int       @default(5)
  nextRetryAt   DateTime? // Exponential backoff
  status        String    @default("pending") // pending, retrying, resolved, abandoned
  resolvedAt    DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  @@unique([itemType, resourceId])
  @@index([status])
  @@index([nextRetryAt])
  @@index([itemType])
}

// ============================================
// FABRIC RECONCILIATION
// ============================================

model FabricReconciliation {
  id            String    @id @default(uuid())
  reconcileDate DateTime  @default(now())
  status        String    @default("draft") // draft, submitted
  notes         String?
  createdBy     String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  items FabricReconciliationItem[]

  @@index([status])
  @@index([createdAt])
}

model FabricReconciliationItem {
  id               String  @id @default(uuid())
  reconciliationId String
  fabricId         String
  systemQty        Float                   // Qty as per system at time of count
  physicalQty      Float?                  // Qty counted physically
  variance         Float?                  // physicalQty - systemQty
  adjustmentReason String?                 // shrinkage, wastage, damaged, found, etc.
  notes            String?
  txnId            String? @unique         // Reference to created FabricTransaction

  reconciliation FabricReconciliation @relation(fields: [reconciliationId], references: [id], onDelete: Cascade)
  fabric         Fabric               @relation(fields: [fabricId], references: [id])

  @@index([reconciliationId])
  @@index([fabricId])
}
